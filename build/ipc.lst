ARM GAS  /tmp/ccDOLSjn.s 			page 1


   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"ipc.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.rt_sem_init,"ax",%progbits
  18              		.align	1
  19              		.global	rt_sem_init
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  24              	rt_sem_init:
  25              	.LVL0:
  26              	.LFB19:
  27              		.file 1 "rt_thread/src/ipc.c"
   1:rt_thread/src/ipc.c **** /*
   2:rt_thread/src/ipc.c ****  * Copyright (c) 2006-2021, RT-Thread Development Team
   3:rt_thread/src/ipc.c ****  *
   4:rt_thread/src/ipc.c ****  * SPDX-License-Identifier: Apache-2.0
   5:rt_thread/src/ipc.c ****  *
   6:rt_thread/src/ipc.c ****  * Change Logs:
   7:rt_thread/src/ipc.c ****  * Date           Author       Notes
   8:rt_thread/src/ipc.c ****  * 2006-03-14     Bernard      the first version
   9:rt_thread/src/ipc.c ****  * 2006-04-25     Bernard      implement semaphore
  10:rt_thread/src/ipc.c ****  * 2006-05-03     Bernard      add RT_IPC_DEBUG
  11:rt_thread/src/ipc.c ****  *                             modify the type of IPC waiting time to rt_int32_t
  12:rt_thread/src/ipc.c ****  * 2006-05-10     Bernard      fix the semaphore take bug and add IPC object
  13:rt_thread/src/ipc.c ****  * 2006-05-12     Bernard      implement mailbox and message queue
  14:rt_thread/src/ipc.c ****  * 2006-05-20     Bernard      implement mutex
  15:rt_thread/src/ipc.c ****  * 2006-05-23     Bernard      implement fast event
  16:rt_thread/src/ipc.c ****  * 2006-05-24     Bernard      implement event
  17:rt_thread/src/ipc.c ****  * 2006-06-03     Bernard      fix the thread timer init bug
  18:rt_thread/src/ipc.c ****  * 2006-06-05     Bernard      fix the mutex release bug
  19:rt_thread/src/ipc.c ****  * 2006-06-07     Bernard      fix the message queue send bug
  20:rt_thread/src/ipc.c ****  * 2006-08-04     Bernard      add hook support
  21:rt_thread/src/ipc.c ****  * 2009-05-21     Yi.qiu       fix the sem release bug
  22:rt_thread/src/ipc.c ****  * 2009-07-18     Bernard      fix the event clear bug
  23:rt_thread/src/ipc.c ****  * 2009-09-09     Bernard      remove fast event and fix ipc release bug
  24:rt_thread/src/ipc.c ****  * 2009-10-10     Bernard      change semaphore and mutex value to unsigned value
  25:rt_thread/src/ipc.c ****  * 2009-10-25     Bernard      change the mb/mq receive timeout to 0 if the
  26:rt_thread/src/ipc.c ****  *                             re-calculated delta tick is a negative number.
  27:rt_thread/src/ipc.c ****  * 2009-12-16     Bernard      fix the rt_ipc_object_suspend issue when IPC flag
  28:rt_thread/src/ipc.c ****  *                             is RT_IPC_FLAG_PRIO
  29:rt_thread/src/ipc.c ****  * 2010-01-20     mbbill       remove rt_ipc_object_decrease function.
  30:rt_thread/src/ipc.c ****  * 2010-04-20     Bernard      move memcpy outside interrupt disable in mq
  31:rt_thread/src/ipc.c ****  * 2010-10-26     yi.qiu       add module support in rt_mp_delete and rt_mq_delete
ARM GAS  /tmp/ccDOLSjn.s 			page 2


  32:rt_thread/src/ipc.c ****  * 2010-11-10     Bernard      add IPC reset command implementation.
  33:rt_thread/src/ipc.c ****  * 2011-12-18     Bernard      add more parameter checking in message queue
  34:rt_thread/src/ipc.c ****  * 2013-09-14     Grissiom     add an option check in rt_event_recv
  35:rt_thread/src/ipc.c ****  * 2018-10-02     Bernard      add 64bit support for mailbox
  36:rt_thread/src/ipc.c ****  * 2019-09-16     tyx          add send wait support for message queue
  37:rt_thread/src/ipc.c ****  * 2020-07-29     Meco Man     fix thread->event_set/event_info when received an
  38:rt_thread/src/ipc.c ****  *                             event without pending
  39:rt_thread/src/ipc.c ****  * 2020-10-11     Meco Man     add value overflow-check code
  40:rt_thread/src/ipc.c ****  */
  41:rt_thread/src/ipc.c **** 
  42:rt_thread/src/ipc.c **** #include <rtthread.h>
  43:rt_thread/src/ipc.c **** #include <rthw.h>
  44:rt_thread/src/ipc.c **** 
  45:rt_thread/src/ipc.c **** #ifdef RT_USING_HOOK
  46:rt_thread/src/ipc.c **** extern void (*rt_object_trytake_hook)(struct rt_object *object);
  47:rt_thread/src/ipc.c **** extern void (*rt_object_take_hook)(struct rt_object *object);
  48:rt_thread/src/ipc.c **** extern void (*rt_object_put_hook)(struct rt_object *object);
  49:rt_thread/src/ipc.c **** #endif
  50:rt_thread/src/ipc.c **** 
  51:rt_thread/src/ipc.c **** /**
  52:rt_thread/src/ipc.c ****  * @addtogroup IPC
  53:rt_thread/src/ipc.c ****  */
  54:rt_thread/src/ipc.c **** 
  55:rt_thread/src/ipc.c **** /**@{*/
  56:rt_thread/src/ipc.c **** 
  57:rt_thread/src/ipc.c **** /**
  58:rt_thread/src/ipc.c ****  * This function will initialize an IPC object
  59:rt_thread/src/ipc.c ****  *
  60:rt_thread/src/ipc.c ****  * @param ipc the IPC object
  61:rt_thread/src/ipc.c ****  *
  62:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
  63:rt_thread/src/ipc.c ****  */
  64:rt_thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
  65:rt_thread/src/ipc.c **** {
  66:rt_thread/src/ipc.c ****     /* initialize ipc object */
  67:rt_thread/src/ipc.c ****     rt_list_init(&(ipc->suspend_thread));
  68:rt_thread/src/ipc.c **** 
  69:rt_thread/src/ipc.c ****     return RT_EOK;
  70:rt_thread/src/ipc.c **** }
  71:rt_thread/src/ipc.c **** 
  72:rt_thread/src/ipc.c **** /**
  73:rt_thread/src/ipc.c ****  * This function will suspend a thread to a specified list. IPC object or some
  74:rt_thread/src/ipc.c ****  * double-queue object (mailbox etc.) contains this kind of list.
  75:rt_thread/src/ipc.c ****  *
  76:rt_thread/src/ipc.c ****  * @param list the IPC suspended thread list
  77:rt_thread/src/ipc.c ****  * @param thread the thread object to be suspended
  78:rt_thread/src/ipc.c ****  * @param flag the IPC object flag,
  79:rt_thread/src/ipc.c ****  *        which shall be RT_IPC_FLAG_FIFO/RT_IPC_FLAG_PRIO.
  80:rt_thread/src/ipc.c ****  *
  81:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
  82:rt_thread/src/ipc.c ****  */
  83:rt_thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
  84:rt_thread/src/ipc.c ****                                        struct rt_thread *thread,
  85:rt_thread/src/ipc.c ****                                        rt_uint8_t        flag)
  86:rt_thread/src/ipc.c **** {
  87:rt_thread/src/ipc.c ****     /* suspend thread */
  88:rt_thread/src/ipc.c ****     rt_thread_suspend(thread);
ARM GAS  /tmp/ccDOLSjn.s 			page 3


  89:rt_thread/src/ipc.c **** 
  90:rt_thread/src/ipc.c ****     switch (flag)
  91:rt_thread/src/ipc.c ****     {
  92:rt_thread/src/ipc.c ****     case RT_IPC_FLAG_FIFO:
  93:rt_thread/src/ipc.c ****         rt_list_insert_before(list, &(thread->tlist));
  94:rt_thread/src/ipc.c ****         break;
  95:rt_thread/src/ipc.c **** 
  96:rt_thread/src/ipc.c ****     case RT_IPC_FLAG_PRIO:
  97:rt_thread/src/ipc.c ****         {
  98:rt_thread/src/ipc.c ****             struct rt_list_node *n;
  99:rt_thread/src/ipc.c ****             struct rt_thread *sthread;
 100:rt_thread/src/ipc.c **** 
 101:rt_thread/src/ipc.c ****             /* find a suitable position */
 102:rt_thread/src/ipc.c ****             for (n = list->next; n != list; n = n->next)
 103:rt_thread/src/ipc.c ****             {
 104:rt_thread/src/ipc.c ****                 sthread = rt_list_entry(n, struct rt_thread, tlist);
 105:rt_thread/src/ipc.c **** 
 106:rt_thread/src/ipc.c ****                 /* find out */
 107:rt_thread/src/ipc.c ****                 if (thread->current_priority < sthread->current_priority)
 108:rt_thread/src/ipc.c ****                 {
 109:rt_thread/src/ipc.c ****                     /* insert this thread before the sthread */
 110:rt_thread/src/ipc.c ****                     rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
 111:rt_thread/src/ipc.c ****                     break;
 112:rt_thread/src/ipc.c ****                 }
 113:rt_thread/src/ipc.c ****             }
 114:rt_thread/src/ipc.c **** 
 115:rt_thread/src/ipc.c ****             /*
 116:rt_thread/src/ipc.c ****              * not found a suitable position,
 117:rt_thread/src/ipc.c ****              * append to the end of suspend_thread list
 118:rt_thread/src/ipc.c ****              */
 119:rt_thread/src/ipc.c ****             if (n == list)
 120:rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 121:rt_thread/src/ipc.c ****         }
 122:rt_thread/src/ipc.c ****         break;
 123:rt_thread/src/ipc.c **** 
 124:rt_thread/src/ipc.c ****     default:
 125:rt_thread/src/ipc.c ****         break;
 126:rt_thread/src/ipc.c ****     }
 127:rt_thread/src/ipc.c **** 
 128:rt_thread/src/ipc.c ****     return RT_EOK;
 129:rt_thread/src/ipc.c **** }
 130:rt_thread/src/ipc.c **** 
 131:rt_thread/src/ipc.c **** /**
 132:rt_thread/src/ipc.c ****  * This function will resume the first thread in the list of a IPC object:
 133:rt_thread/src/ipc.c ****  * - remove the thread from suspend queue of IPC object
 134:rt_thread/src/ipc.c ****  * - put the thread into system ready queue
 135:rt_thread/src/ipc.c ****  *
 136:rt_thread/src/ipc.c ****  * @param list the thread list
 137:rt_thread/src/ipc.c ****  *
 138:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 139:rt_thread/src/ipc.c ****  */
 140:rt_thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
 141:rt_thread/src/ipc.c **** {
 142:rt_thread/src/ipc.c ****     struct rt_thread *thread;
 143:rt_thread/src/ipc.c **** 
 144:rt_thread/src/ipc.c ****     /* get thread entry */
 145:rt_thread/src/ipc.c ****     thread = rt_list_entry(list->next, struct rt_thread, tlist);
ARM GAS  /tmp/ccDOLSjn.s 			page 4


 146:rt_thread/src/ipc.c **** 
 147:rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));
 148:rt_thread/src/ipc.c **** 
 149:rt_thread/src/ipc.c ****     /* resume it */
 150:rt_thread/src/ipc.c ****     rt_thread_resume(thread);
 151:rt_thread/src/ipc.c **** 
 152:rt_thread/src/ipc.c ****     return RT_EOK;
 153:rt_thread/src/ipc.c **** }
 154:rt_thread/src/ipc.c **** 
 155:rt_thread/src/ipc.c **** /**
 156:rt_thread/src/ipc.c ****  * This function will resume all suspended threads in a list, including
 157:rt_thread/src/ipc.c ****  * suspend list of IPC object and private list of mailbox etc.
 158:rt_thread/src/ipc.c ****  *
 159:rt_thread/src/ipc.c ****  * @param list of the threads to resume
 160:rt_thread/src/ipc.c ****  *
 161:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 162:rt_thread/src/ipc.c ****  */
 163:rt_thread/src/ipc.c **** rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
 164:rt_thread/src/ipc.c **** {
 165:rt_thread/src/ipc.c ****     struct rt_thread *thread;
 166:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 167:rt_thread/src/ipc.c **** 
 168:rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 169:rt_thread/src/ipc.c ****     while (!rt_list_isempty(list))
 170:rt_thread/src/ipc.c ****     {
 171:rt_thread/src/ipc.c ****         /* disable interrupt */
 172:rt_thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
 173:rt_thread/src/ipc.c **** 
 174:rt_thread/src/ipc.c ****         /* get next suspended thread */
 175:rt_thread/src/ipc.c ****         thread = rt_list_entry(list->next, struct rt_thread, tlist);
 176:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 177:rt_thread/src/ipc.c ****         thread->error = -RT_ERROR;
 178:rt_thread/src/ipc.c **** 
 179:rt_thread/src/ipc.c ****         /*
 180:rt_thread/src/ipc.c ****          * resume thread
 181:rt_thread/src/ipc.c ****          * In rt_thread_resume function, it will remove current thread from
 182:rt_thread/src/ipc.c ****          * suspended list
 183:rt_thread/src/ipc.c ****          */
 184:rt_thread/src/ipc.c ****         rt_thread_resume(thread);
 185:rt_thread/src/ipc.c **** 
 186:rt_thread/src/ipc.c ****         /* enable interrupt */
 187:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 188:rt_thread/src/ipc.c ****     }
 189:rt_thread/src/ipc.c **** 
 190:rt_thread/src/ipc.c ****     return RT_EOK;
 191:rt_thread/src/ipc.c **** }
 192:rt_thread/src/ipc.c **** 
 193:rt_thread/src/ipc.c **** #ifdef RT_USING_SEMAPHORE
 194:rt_thread/src/ipc.c **** /**
 195:rt_thread/src/ipc.c ****  * This function will initialize a semaphore and put it under control of
 196:rt_thread/src/ipc.c ****  * resource management.
 197:rt_thread/src/ipc.c ****  *
 198:rt_thread/src/ipc.c ****  * @param sem the semaphore object
 199:rt_thread/src/ipc.c ****  * @param name the name of semaphore
 200:rt_thread/src/ipc.c ****  * @param value the initial value of semaphore
 201:rt_thread/src/ipc.c ****  * @param flag the flag of semaphore
 202:rt_thread/src/ipc.c ****  *
ARM GAS  /tmp/ccDOLSjn.s 			page 5


 203:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 204:rt_thread/src/ipc.c ****  */
 205:rt_thread/src/ipc.c **** rt_err_t rt_sem_init(rt_sem_t    sem,
 206:rt_thread/src/ipc.c ****                      const char *name,
 207:rt_thread/src/ipc.c ****                      rt_uint32_t value,
 208:rt_thread/src/ipc.c ****                      rt_uint8_t  flag)
 209:rt_thread/src/ipc.c **** {
  28              		.loc 1 209 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		.loc 1 209 1 is_stmt 0 view .LVU1
  33 0000 70B5     		push	{r4, r5, r6, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 16
  36              		.cfi_offset 4, -16
  37              		.cfi_offset 5, -12
  38              		.cfi_offset 6, -8
  39              		.cfi_offset 14, -4
  40 0002 0446     		mov	r4, r0
  41 0004 1646     		mov	r6, r2
  42 0006 1D46     		mov	r5, r3
 210:rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
  43              		.loc 1 210 30 is_stmt 1 view .LVU2
 211:rt_thread/src/ipc.c ****     RT_ASSERT(value < 0x10000U);
  44              		.loc 1 211 32 view .LVU3
 212:rt_thread/src/ipc.c **** 
 213:rt_thread/src/ipc.c ****     /* initialize object */
 214:rt_thread/src/ipc.c ****     rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
  45              		.loc 1 214 5 view .LVU4
  46 0008 0A46     		mov	r2, r1
  47              	.LVL1:
  48              		.loc 1 214 5 is_stmt 0 view .LVU5
  49 000a 0221     		movs	r1, #2
  50              	.LVL2:
  51              		.loc 1 214 5 view .LVU6
  52 000c FFF7FEFF 		bl	rt_object_init
  53              	.LVL3:
 215:rt_thread/src/ipc.c **** 
 216:rt_thread/src/ipc.c ****     /* initialize ipc object */
 217:rt_thread/src/ipc.c ****     rt_ipc_object_init(&(sem->parent));
  54              		.loc 1 217 5 is_stmt 1 view .LVU7
  55              	.LBB45:
  56              	.LBI45:
  64:rt_thread/src/ipc.c **** {
  57              		.loc 1 64 20 view .LVU8
  58              	.LBB46:
  67:rt_thread/src/ipc.c **** 
  59              		.loc 1 67 5 view .LVU9
  60 0010 04F11403 		add	r3, r4, #20
  61              	.LVL4:
  62              	.LBB47:
  63              	.LBI47:
  64              		.file 2 "rt_thread/include/rtservice.h"
   1:rt_thread/include/rtservice.h **** /*
   2:rt_thread/include/rtservice.h ****  * Copyright (c) 2006-2021, RT-Thread Development Team
   3:rt_thread/include/rtservice.h ****  *
ARM GAS  /tmp/ccDOLSjn.s 			page 6


   4:rt_thread/include/rtservice.h ****  * SPDX-License-Identifier: Apache-2.0
   5:rt_thread/include/rtservice.h ****  *
   6:rt_thread/include/rtservice.h ****  * Change Logs:
   7:rt_thread/include/rtservice.h ****  * Date           Author       Notes
   8:rt_thread/include/rtservice.h ****  * 2006-03-16     Bernard      the first version
   9:rt_thread/include/rtservice.h ****  * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
  10:rt_thread/include/rtservice.h ****  * 2007-06-27     Bernard      fix the rt_list_remove bug
  11:rt_thread/include/rtservice.h ****  * 2012-03-22     Bernard      rename kservice.h to rtservice.h
  12:rt_thread/include/rtservice.h ****  * 2017-11-15     JasonJia     Modify rt_slist_foreach to rt_slist_for_each_entry.
  13:rt_thread/include/rtservice.h ****  *                             Make code cleanup.
  14:rt_thread/include/rtservice.h ****  */
  15:rt_thread/include/rtservice.h **** 
  16:rt_thread/include/rtservice.h **** #ifndef __RT_SERVICE_H__
  17:rt_thread/include/rtservice.h **** #define __RT_SERVICE_H__
  18:rt_thread/include/rtservice.h **** 
  19:rt_thread/include/rtservice.h **** #ifdef __cplusplus
  20:rt_thread/include/rtservice.h **** extern "C" {
  21:rt_thread/include/rtservice.h **** #endif
  22:rt_thread/include/rtservice.h **** 
  23:rt_thread/include/rtservice.h **** /**
  24:rt_thread/include/rtservice.h ****  * @addtogroup KernelService
  25:rt_thread/include/rtservice.h ****  */
  26:rt_thread/include/rtservice.h **** 
  27:rt_thread/include/rtservice.h **** /**@{*/
  28:rt_thread/include/rtservice.h **** 
  29:rt_thread/include/rtservice.h **** /**
  30:rt_thread/include/rtservice.h ****  * rt_container_of - return the member address of ptr, if the type of ptr is the
  31:rt_thread/include/rtservice.h ****  * struct type.
  32:rt_thread/include/rtservice.h ****  */
  33:rt_thread/include/rtservice.h **** #define rt_container_of(ptr, type, member) \
  34:rt_thread/include/rtservice.h ****     ((type *)((char *)(ptr) - (unsigned long)(&((type *)0)->member)))
  35:rt_thread/include/rtservice.h **** 
  36:rt_thread/include/rtservice.h **** 
  37:rt_thread/include/rtservice.h **** /**
  38:rt_thread/include/rtservice.h ****  * @brief initialize a list object
  39:rt_thread/include/rtservice.h ****  */
  40:rt_thread/include/rtservice.h **** #define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
  41:rt_thread/include/rtservice.h **** 
  42:rt_thread/include/rtservice.h **** /**
  43:rt_thread/include/rtservice.h ****  * @brief initialize a list
  44:rt_thread/include/rtservice.h ****  *
  45:rt_thread/include/rtservice.h ****  * @param l list to be initialized
  46:rt_thread/include/rtservice.h ****  */
  47:rt_thread/include/rtservice.h **** rt_inline void rt_list_init(rt_list_t *l)
  65              		.loc 2 47 16 view .LVU10
  66              	.LBB48:
  48:rt_thread/include/rtservice.h **** {
  49:rt_thread/include/rtservice.h ****     l->next = l->prev = l;
  67              		.loc 2 49 5 view .LVU11
  68              		.loc 2 49 23 is_stmt 0 view .LVU12
  69 0014 A361     		str	r3, [r4, #24]
  70              		.loc 2 49 13 view .LVU13
  71 0016 6361     		str	r3, [r4, #20]
  72              	.LVL5:
  73              		.loc 2 49 13 view .LVU14
  74              	.LBE48:
  75              	.LBE47:
ARM GAS  /tmp/ccDOLSjn.s 			page 7


  69:rt_thread/src/ipc.c **** }
  76              		.loc 1 69 5 is_stmt 1 view .LVU15
  69:rt_thread/src/ipc.c **** }
  77              		.loc 1 69 5 is_stmt 0 view .LVU16
  78              	.LBE46:
  79              	.LBE45:
 218:rt_thread/src/ipc.c **** 
 219:rt_thread/src/ipc.c ****     /* set initial value */
 220:rt_thread/src/ipc.c ****     sem->value = (rt_uint16_t)value;
  80              		.loc 1 220 5 is_stmt 1 view .LVU17
  81              		.loc 1 220 16 is_stmt 0 view .LVU18
  82 0018 A683     		strh	r6, [r4, #28]	@ movhi
 221:rt_thread/src/ipc.c **** 
 222:rt_thread/src/ipc.c ****     /* set parent */
 223:rt_thread/src/ipc.c ****     sem->parent.parent.flag = flag;
  83              		.loc 1 223 5 is_stmt 1 view .LVU19
  84              		.loc 1 223 29 is_stmt 0 view .LVU20
  85 001a 6572     		strb	r5, [r4, #9]
 224:rt_thread/src/ipc.c **** 
 225:rt_thread/src/ipc.c ****     return RT_EOK;
  86              		.loc 1 225 5 is_stmt 1 view .LVU21
 226:rt_thread/src/ipc.c **** }
  87              		.loc 1 226 1 is_stmt 0 view .LVU22
  88 001c 0020     		movs	r0, #0
  89 001e 70BD     		pop	{r4, r5, r6, pc}
  90              		.loc 1 226 1 view .LVU23
  91              		.cfi_endproc
  92              	.LFE19:
  94              		.section	.text.rt_sem_detach,"ax",%progbits
  95              		.align	1
  96              		.global	rt_sem_detach
  97              		.syntax unified
  98              		.thumb
  99              		.thumb_func
 101              	rt_sem_detach:
 102              	.LVL6:
 103              	.LFB20:
 227:rt_thread/src/ipc.c **** 
 228:rt_thread/src/ipc.c **** /**
 229:rt_thread/src/ipc.c ****  * This function will detach a semaphore from resource management
 230:rt_thread/src/ipc.c ****  *
 231:rt_thread/src/ipc.c ****  * @param sem the semaphore object
 232:rt_thread/src/ipc.c ****  *
 233:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 234:rt_thread/src/ipc.c ****  *
 235:rt_thread/src/ipc.c ****  * @see rt_sem_delete
 236:rt_thread/src/ipc.c ****  */
 237:rt_thread/src/ipc.c **** rt_err_t rt_sem_detach(rt_sem_t sem)
 238:rt_thread/src/ipc.c **** {
 104              		.loc 1 238 1 is_stmt 1 view -0
 105              		.cfi_startproc
 106              		@ args = 0, pretend = 0, frame = 0
 107              		@ frame_needed = 0, uses_anonymous_args = 0
 108              		.loc 1 238 1 is_stmt 0 view .LVU25
 109 0000 70B5     		push	{r4, r5, r6, lr}
 110              	.LCFI1:
 111              		.cfi_def_cfa_offset 16
ARM GAS  /tmp/ccDOLSjn.s 			page 8


 112              		.cfi_offset 4, -16
 113              		.cfi_offset 5, -12
 114              		.cfi_offset 6, -8
 115              		.cfi_offset 14, -4
 116 0002 0646     		mov	r6, r0
 239:rt_thread/src/ipc.c ****     /* parameter check */
 240:rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 117              		.loc 1 240 30 is_stmt 1 view .LVU26
 241:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 118              		.loc 1 241 84 view .LVU27
 242:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&sem->parent.parent));
 119              		.loc 1 242 62 view .LVU28
 243:rt_thread/src/ipc.c **** 
 244:rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 245:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
 120              		.loc 1 245 5 view .LVU29
 121 0004 00F11405 		add	r5, r0, #20
 122              	.LVL7:
 123              	.LBB53:
 124              	.LBI53:
 163:rt_thread/src/ipc.c **** {
 125              		.loc 1 163 20 view .LVU30
 126              	.LBB54:
 165:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 127              		.loc 1 165 5 view .LVU31
 166:rt_thread/src/ipc.c **** 
 128              		.loc 1 166 5 view .LVU32
 169:rt_thread/src/ipc.c ****     {
 129              		.loc 1 169 5 view .LVU33
 169:rt_thread/src/ipc.c ****     {
 130              		.loc 1 169 11 is_stmt 0 view .LVU34
 131 0008 0CE0     		b	.L4
 132              	.LVL8:
 133              	.L5:
 172:rt_thread/src/ipc.c **** 
 134              		.loc 1 172 9 is_stmt 1 view .LVU35
 172:rt_thread/src/ipc.c **** 
 135              		.loc 1 172 16 is_stmt 0 view .LVU36
 136 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 137              	.LVL9:
 138 000e 0446     		mov	r4, r0
 139              	.LVL10:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 140              		.loc 1 175 9 is_stmt 1 view .LVU37
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 141              		.loc 1 175 18 is_stmt 0 view .LVU38
 142 0010 2868     		ldr	r0, [r5]
 143              	.LVL11:
 177:rt_thread/src/ipc.c **** 
 144              		.loc 1 177 9 is_stmt 1 view .LVU39
 177:rt_thread/src/ipc.c **** 
 145              		.loc 1 177 23 is_stmt 0 view .LVU40
 146 0012 4FF0FF33 		mov	r3, #-1
 147 0016 C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 148              		.loc 1 184 9 is_stmt 1 view .LVU41
 149 0018 1438     		subs	r0, r0, #20
ARM GAS  /tmp/ccDOLSjn.s 			page 9


 150              	.LVL12:
 184:rt_thread/src/ipc.c **** 
 151              		.loc 1 184 9 is_stmt 0 view .LVU42
 152 001a FFF7FEFF 		bl	rt_thread_resume
 153              	.LVL13:
 187:rt_thread/src/ipc.c ****     }
 154              		.loc 1 187 9 is_stmt 1 view .LVU43
 155 001e 2046     		mov	r0, r4
 156 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 157              	.LVL14:
 158              	.L4:
 169:rt_thread/src/ipc.c ****     {
 159              		.loc 1 169 11 view .LVU44
 160              	.LBB55:
 161              	.LBI55:
  50:rt_thread/include/rtservice.h **** }
  51:rt_thread/include/rtservice.h **** 
  52:rt_thread/include/rtservice.h **** /**
  53:rt_thread/include/rtservice.h ****  * @brief insert a node after a list
  54:rt_thread/include/rtservice.h ****  *
  55:rt_thread/include/rtservice.h ****  * @param l list to insert it
  56:rt_thread/include/rtservice.h ****  * @param n new node to be inserted
  57:rt_thread/include/rtservice.h ****  */
  58:rt_thread/include/rtservice.h **** rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
  59:rt_thread/include/rtservice.h **** {
  60:rt_thread/include/rtservice.h ****     l->next->prev = n;
  61:rt_thread/include/rtservice.h ****     n->next = l->next;
  62:rt_thread/include/rtservice.h **** 
  63:rt_thread/include/rtservice.h ****     l->next = n;
  64:rt_thread/include/rtservice.h ****     n->prev = l;
  65:rt_thread/include/rtservice.h **** }
  66:rt_thread/include/rtservice.h **** 
  67:rt_thread/include/rtservice.h **** /**
  68:rt_thread/include/rtservice.h ****  * @brief insert a node before a list
  69:rt_thread/include/rtservice.h ****  *
  70:rt_thread/include/rtservice.h ****  * @param n new node to be inserted
  71:rt_thread/include/rtservice.h ****  * @param l list to insert it
  72:rt_thread/include/rtservice.h ****  */
  73:rt_thread/include/rtservice.h **** rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
  74:rt_thread/include/rtservice.h **** {
  75:rt_thread/include/rtservice.h ****     l->prev->next = n;
  76:rt_thread/include/rtservice.h ****     n->prev = l->prev;
  77:rt_thread/include/rtservice.h **** 
  78:rt_thread/include/rtservice.h ****     l->prev = n;
  79:rt_thread/include/rtservice.h ****     n->next = l;
  80:rt_thread/include/rtservice.h **** }
  81:rt_thread/include/rtservice.h **** 
  82:rt_thread/include/rtservice.h **** /**
  83:rt_thread/include/rtservice.h ****  * @brief remove node from list.
  84:rt_thread/include/rtservice.h ****  * @param n the node to remove from the list.
  85:rt_thread/include/rtservice.h ****  */
  86:rt_thread/include/rtservice.h **** rt_inline void rt_list_remove(rt_list_t *n)
  87:rt_thread/include/rtservice.h **** {
  88:rt_thread/include/rtservice.h ****     n->next->prev = n->prev;
  89:rt_thread/include/rtservice.h ****     n->prev->next = n->next;
  90:rt_thread/include/rtservice.h **** 
  91:rt_thread/include/rtservice.h ****     n->next = n->prev = n;
ARM GAS  /tmp/ccDOLSjn.s 			page 10


  92:rt_thread/include/rtservice.h **** }
  93:rt_thread/include/rtservice.h **** 
  94:rt_thread/include/rtservice.h **** /**
  95:rt_thread/include/rtservice.h ****  * @brief tests whether a list is empty
  96:rt_thread/include/rtservice.h ****  * @param l the list to test.
  97:rt_thread/include/rtservice.h ****  */
  98:rt_thread/include/rtservice.h **** rt_inline int rt_list_isempty(const rt_list_t *l)
 162              		.loc 2 98 15 view .LVU45
 163              	.LBB56:
  99:rt_thread/include/rtservice.h **** {
 100:rt_thread/include/rtservice.h ****     return l->next == l;
 164              		.loc 2 100 5 view .LVU46
 165              		.loc 2 100 13 is_stmt 0 view .LVU47
 166 0024 2B68     		ldr	r3, [r5]
 167              	.LVL15:
 168              		.loc 2 100 13 view .LVU48
 169              	.LBE56:
 170              	.LBE55:
 169:rt_thread/src/ipc.c ****     {
 171              		.loc 1 169 11 view .LVU49
 172 0026 9D42     		cmp	r5, r3
 173 0028 EFD1     		bne	.L5
 190:rt_thread/src/ipc.c **** }
 174              		.loc 1 190 5 is_stmt 1 view .LVU50
 175              	.LVL16:
 190:rt_thread/src/ipc.c **** }
 176              		.loc 1 190 5 is_stmt 0 view .LVU51
 177              	.LBE54:
 178              	.LBE53:
 246:rt_thread/src/ipc.c **** 
 247:rt_thread/src/ipc.c ****     /* detach semaphore object */
 248:rt_thread/src/ipc.c ****     rt_object_detach(&(sem->parent.parent));
 179              		.loc 1 248 5 is_stmt 1 view .LVU52
 180 002a 3046     		mov	r0, r6
 181 002c FFF7FEFF 		bl	rt_object_detach
 182              	.LVL17:
 249:rt_thread/src/ipc.c **** 
 250:rt_thread/src/ipc.c ****     return RT_EOK;
 183              		.loc 1 250 5 view .LVU53
 251:rt_thread/src/ipc.c **** }
 184              		.loc 1 251 1 is_stmt 0 view .LVU54
 185 0030 0020     		movs	r0, #0
 186 0032 70BD     		pop	{r4, r5, r6, pc}
 187              		.loc 1 251 1 view .LVU55
 188              		.cfi_endproc
 189              	.LFE20:
 191              		.section	.text.rt_sem_create,"ax",%progbits
 192              		.align	1
 193              		.global	rt_sem_create
 194              		.syntax unified
 195              		.thumb
 196              		.thumb_func
 198              	rt_sem_create:
 199              	.LVL18:
 200              	.LFB21:
 252:rt_thread/src/ipc.c **** 
 253:rt_thread/src/ipc.c **** #ifdef RT_USING_HEAP
ARM GAS  /tmp/ccDOLSjn.s 			page 11


 254:rt_thread/src/ipc.c **** /**
 255:rt_thread/src/ipc.c ****  * This function will create a semaphore from system resource
 256:rt_thread/src/ipc.c ****  *
 257:rt_thread/src/ipc.c ****  * @param name the name of semaphore
 258:rt_thread/src/ipc.c ****  * @param value the initial value of semaphore
 259:rt_thread/src/ipc.c ****  * @param flag the flag of semaphore
 260:rt_thread/src/ipc.c ****  *
 261:rt_thread/src/ipc.c ****  * @return the created semaphore, RT_NULL on error happen
 262:rt_thread/src/ipc.c ****  *
 263:rt_thread/src/ipc.c ****  * @see rt_sem_init
 264:rt_thread/src/ipc.c ****  */
 265:rt_thread/src/ipc.c **** rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
 266:rt_thread/src/ipc.c **** {
 201              		.loc 1 266 1 is_stmt 1 view -0
 202              		.cfi_startproc
 203              		@ args = 0, pretend = 0, frame = 0
 204              		@ frame_needed = 0, uses_anonymous_args = 0
 205              		.loc 1 266 1 is_stmt 0 view .LVU57
 206 0000 38B5     		push	{r3, r4, r5, lr}
 207              	.LCFI2:
 208              		.cfi_def_cfa_offset 16
 209              		.cfi_offset 3, -16
 210              		.cfi_offset 4, -12
 211              		.cfi_offset 5, -8
 212              		.cfi_offset 14, -4
 213 0002 0D46     		mov	r5, r1
 214 0004 1446     		mov	r4, r2
 267:rt_thread/src/ipc.c ****     rt_sem_t sem;
 215              		.loc 1 267 5 is_stmt 1 view .LVU58
 268:rt_thread/src/ipc.c **** 
 269:rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 216              		.loc 1 269 30 view .LVU59
 270:rt_thread/src/ipc.c ****     RT_ASSERT(value < 0x10000U);
 217              		.loc 1 270 32 view .LVU60
 271:rt_thread/src/ipc.c **** 
 272:rt_thread/src/ipc.c ****     /* allocate object */
 273:rt_thread/src/ipc.c ****     sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
 218              		.loc 1 273 5 view .LVU61
 219              		.loc 1 273 21 is_stmt 0 view .LVU62
 220 0006 0146     		mov	r1, r0
 221              	.LVL19:
 222              		.loc 1 273 21 view .LVU63
 223 0008 0220     		movs	r0, #2
 224              	.LVL20:
 225              		.loc 1 273 21 view .LVU64
 226 000a FFF7FEFF 		bl	rt_object_allocate
 227              	.LVL21:
 274:rt_thread/src/ipc.c ****     if (sem == RT_NULL)
 228              		.loc 1 274 5 is_stmt 1 view .LVU65
 229              		.loc 1 274 8 is_stmt 0 view .LVU66
 230 000e 0346     		mov	r3, r0
 231 0010 28B1     		cbz	r0, .L7
 275:rt_thread/src/ipc.c ****         return sem;
 276:rt_thread/src/ipc.c **** 
 277:rt_thread/src/ipc.c ****     /* initialize ipc object */
 278:rt_thread/src/ipc.c ****     rt_ipc_object_init(&(sem->parent));
 232              		.loc 1 278 5 is_stmt 1 view .LVU67
ARM GAS  /tmp/ccDOLSjn.s 			page 12


 233              	.LVL22:
 234              	.LBB57:
 235              	.LBI57:
  64:rt_thread/src/ipc.c **** {
 236              		.loc 1 64 20 view .LVU68
 237              	.LBB58:
  67:rt_thread/src/ipc.c **** 
 238              		.loc 1 67 5 view .LVU69
 239 0012 00F11402 		add	r2, r0, #20
 240              	.LVL23:
 241              	.LBB59:
 242              	.LBI59:
  47:rt_thread/include/rtservice.h **** {
 243              		.loc 2 47 16 view .LVU70
 244              	.LBB60:
  49:rt_thread/include/rtservice.h **** }
 245              		.loc 2 49 5 view .LVU71
  49:rt_thread/include/rtservice.h **** }
 246              		.loc 2 49 23 is_stmt 0 view .LVU72
 247 0016 8261     		str	r2, [r0, #24]
  49:rt_thread/include/rtservice.h **** }
 248              		.loc 2 49 13 view .LVU73
 249 0018 4261     		str	r2, [r0, #20]
 250              	.LVL24:
  49:rt_thread/include/rtservice.h **** }
 251              		.loc 2 49 13 view .LVU74
 252              	.LBE60:
 253              	.LBE59:
  69:rt_thread/src/ipc.c **** }
 254              		.loc 1 69 5 is_stmt 1 view .LVU75
  69:rt_thread/src/ipc.c **** }
 255              		.loc 1 69 5 is_stmt 0 view .LVU76
 256              	.LBE58:
 257              	.LBE57:
 279:rt_thread/src/ipc.c **** 
 280:rt_thread/src/ipc.c ****     /* set initial value */
 281:rt_thread/src/ipc.c ****     sem->value = value;
 258              		.loc 1 281 5 is_stmt 1 view .LVU77
 259              		.loc 1 281 16 is_stmt 0 view .LVU78
 260 001a 8583     		strh	r5, [r0, #28]	@ movhi
 282:rt_thread/src/ipc.c **** 
 283:rt_thread/src/ipc.c ****     /* set parent */
 284:rt_thread/src/ipc.c ****     sem->parent.parent.flag = flag;
 261              		.loc 1 284 5 is_stmt 1 view .LVU79
 262              		.loc 1 284 29 is_stmt 0 view .LVU80
 263 001c 4472     		strb	r4, [r0, #9]
 285:rt_thread/src/ipc.c **** 
 286:rt_thread/src/ipc.c ****     return sem;
 264              		.loc 1 286 5 is_stmt 1 view .LVU81
 265              	.L7:
 287:rt_thread/src/ipc.c **** }
 266              		.loc 1 287 1 is_stmt 0 view .LVU82
 267 001e 1846     		mov	r0, r3
 268              	.LVL25:
 269              		.loc 1 287 1 view .LVU83
 270 0020 38BD     		pop	{r3, r4, r5, pc}
 271              		.loc 1 287 1 view .LVU84
ARM GAS  /tmp/ccDOLSjn.s 			page 13


 272              		.cfi_endproc
 273              	.LFE21:
 275              		.section	.text.rt_sem_delete,"ax",%progbits
 276              		.align	1
 277              		.global	rt_sem_delete
 278              		.syntax unified
 279              		.thumb
 280              		.thumb_func
 282              	rt_sem_delete:
 283              	.LVL26:
 284              	.LFB22:
 288:rt_thread/src/ipc.c **** 
 289:rt_thread/src/ipc.c **** /**
 290:rt_thread/src/ipc.c ****  * This function will delete a semaphore object and release the memory
 291:rt_thread/src/ipc.c ****  *
 292:rt_thread/src/ipc.c ****  * @param sem the semaphore object
 293:rt_thread/src/ipc.c ****  *
 294:rt_thread/src/ipc.c ****  * @return the error code
 295:rt_thread/src/ipc.c ****  *
 296:rt_thread/src/ipc.c ****  * @see rt_sem_detach
 297:rt_thread/src/ipc.c ****  */
 298:rt_thread/src/ipc.c **** rt_err_t rt_sem_delete(rt_sem_t sem)
 299:rt_thread/src/ipc.c **** {
 285              		.loc 1 299 1 is_stmt 1 view -0
 286              		.cfi_startproc
 287              		@ args = 0, pretend = 0, frame = 0
 288              		@ frame_needed = 0, uses_anonymous_args = 0
 289              		.loc 1 299 1 is_stmt 0 view .LVU86
 290 0000 70B5     		push	{r4, r5, r6, lr}
 291              	.LCFI3:
 292              		.cfi_def_cfa_offset 16
 293              		.cfi_offset 4, -16
 294              		.cfi_offset 5, -12
 295              		.cfi_offset 6, -8
 296              		.cfi_offset 14, -4
 297 0002 0646     		mov	r6, r0
 300:rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 298              		.loc 1 300 30 is_stmt 1 view .LVU87
 301:rt_thread/src/ipc.c **** 
 302:rt_thread/src/ipc.c ****     /* parameter check */
 303:rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 299              		.loc 1 303 30 view .LVU88
 304:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 300              		.loc 1 304 84 view .LVU89
 305:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&sem->parent.parent) == RT_FALSE);
 301              		.loc 1 305 74 view .LVU90
 306:rt_thread/src/ipc.c **** 
 307:rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 308:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
 302              		.loc 1 308 5 view .LVU91
 303 0004 00F11405 		add	r5, r0, #20
 304              	.LVL27:
 305              	.LBB65:
 306              	.LBI65:
 163:rt_thread/src/ipc.c **** {
 307              		.loc 1 163 20 view .LVU92
 308              	.LBB66:
ARM GAS  /tmp/ccDOLSjn.s 			page 14


 165:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 309              		.loc 1 165 5 view .LVU93
 166:rt_thread/src/ipc.c **** 
 310              		.loc 1 166 5 view .LVU94
 169:rt_thread/src/ipc.c ****     {
 311              		.loc 1 169 5 view .LVU95
 169:rt_thread/src/ipc.c ****     {
 312              		.loc 1 169 11 is_stmt 0 view .LVU96
 313 0008 0CE0     		b	.L11
 314              	.LVL28:
 315              	.L12:
 172:rt_thread/src/ipc.c **** 
 316              		.loc 1 172 9 is_stmt 1 view .LVU97
 172:rt_thread/src/ipc.c **** 
 317              		.loc 1 172 16 is_stmt 0 view .LVU98
 318 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 319              	.LVL29:
 320 000e 0446     		mov	r4, r0
 321              	.LVL30:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 322              		.loc 1 175 9 is_stmt 1 view .LVU99
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 323              		.loc 1 175 18 is_stmt 0 view .LVU100
 324 0010 2868     		ldr	r0, [r5]
 325              	.LVL31:
 177:rt_thread/src/ipc.c **** 
 326              		.loc 1 177 9 is_stmt 1 view .LVU101
 177:rt_thread/src/ipc.c **** 
 327              		.loc 1 177 23 is_stmt 0 view .LVU102
 328 0012 4FF0FF33 		mov	r3, #-1
 329 0016 C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 330              		.loc 1 184 9 is_stmt 1 view .LVU103
 331 0018 1438     		subs	r0, r0, #20
 332              	.LVL32:
 184:rt_thread/src/ipc.c **** 
 333              		.loc 1 184 9 is_stmt 0 view .LVU104
 334 001a FFF7FEFF 		bl	rt_thread_resume
 335              	.LVL33:
 187:rt_thread/src/ipc.c ****     }
 336              		.loc 1 187 9 is_stmt 1 view .LVU105
 337 001e 2046     		mov	r0, r4
 338 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 339              	.LVL34:
 340              	.L11:
 169:rt_thread/src/ipc.c ****     {
 341              		.loc 1 169 11 view .LVU106
 342              	.LBB67:
 343              	.LBI67:
  98:rt_thread/include/rtservice.h **** {
 344              		.loc 2 98 15 view .LVU107
 345              	.LBB68:
 346              		.loc 2 100 5 view .LVU108
 347              		.loc 2 100 13 is_stmt 0 view .LVU109
 348 0024 2B68     		ldr	r3, [r5]
 349              	.LVL35:
 350              		.loc 2 100 13 view .LVU110
ARM GAS  /tmp/ccDOLSjn.s 			page 15


 351              	.LBE68:
 352              	.LBE67:
 169:rt_thread/src/ipc.c ****     {
 353              		.loc 1 169 11 view .LVU111
 354 0026 9D42     		cmp	r5, r3
 355 0028 EFD1     		bne	.L12
 190:rt_thread/src/ipc.c **** }
 356              		.loc 1 190 5 is_stmt 1 view .LVU112
 357              	.LVL36:
 190:rt_thread/src/ipc.c **** }
 358              		.loc 1 190 5 is_stmt 0 view .LVU113
 359              	.LBE66:
 360              	.LBE65:
 309:rt_thread/src/ipc.c **** 
 310:rt_thread/src/ipc.c ****     /* delete semaphore object */
 311:rt_thread/src/ipc.c ****     rt_object_delete(&(sem->parent.parent));
 361              		.loc 1 311 5 is_stmt 1 view .LVU114
 362 002a 3046     		mov	r0, r6
 363 002c FFF7FEFF 		bl	rt_object_delete
 364              	.LVL37:
 312:rt_thread/src/ipc.c **** 
 313:rt_thread/src/ipc.c ****     return RT_EOK;
 365              		.loc 1 313 5 view .LVU115
 314:rt_thread/src/ipc.c **** }
 366              		.loc 1 314 1 is_stmt 0 view .LVU116
 367 0030 0020     		movs	r0, #0
 368 0032 70BD     		pop	{r4, r5, r6, pc}
 369              		.loc 1 314 1 view .LVU117
 370              		.cfi_endproc
 371              	.LFE22:
 373              		.section	.text.rt_sem_take,"ax",%progbits
 374              		.align	1
 375              		.global	rt_sem_take
 376              		.syntax unified
 377              		.thumb
 378              		.thumb_func
 380              	rt_sem_take:
 381              	.LVL38:
 382              	.LFB23:
 315:rt_thread/src/ipc.c **** #endif
 316:rt_thread/src/ipc.c **** 
 317:rt_thread/src/ipc.c **** /**
 318:rt_thread/src/ipc.c ****  * This function will take a semaphore, if the semaphore is unavailable, the
 319:rt_thread/src/ipc.c ****  * thread shall wait for a specified time.
 320:rt_thread/src/ipc.c ****  *
 321:rt_thread/src/ipc.c ****  * @param sem the semaphore object
 322:rt_thread/src/ipc.c ****  * @param time the waiting time
 323:rt_thread/src/ipc.c ****  *
 324:rt_thread/src/ipc.c ****  * @return the error code
 325:rt_thread/src/ipc.c ****  */
 326:rt_thread/src/ipc.c **** rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
 327:rt_thread/src/ipc.c **** {
 383              		.loc 1 327 1 is_stmt 1 view -0
 384              		.cfi_startproc
 385              		@ args = 0, pretend = 0, frame = 8
 386              		@ frame_needed = 0, uses_anonymous_args = 0
 387              		.loc 1 327 1 is_stmt 0 view .LVU119
ARM GAS  /tmp/ccDOLSjn.s 			page 16


 388 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 389              	.LCFI4:
 390              		.cfi_def_cfa_offset 24
 391              		.cfi_offset 4, -24
 392              		.cfi_offset 5, -20
 393              		.cfi_offset 6, -16
 394              		.cfi_offset 7, -12
 395              		.cfi_offset 8, -8
 396              		.cfi_offset 14, -4
 397 0004 82B0     		sub	sp, sp, #8
 398              	.LCFI5:
 399              		.cfi_def_cfa_offset 32
 400 0006 0546     		mov	r5, r0
 401 0008 0191     		str	r1, [sp, #4]
 328:rt_thread/src/ipc.c ****     register rt_base_t temp;
 402              		.loc 1 328 5 is_stmt 1 view .LVU120
 329:rt_thread/src/ipc.c ****     struct rt_thread *thread;
 403              		.loc 1 329 5 view .LVU121
 330:rt_thread/src/ipc.c **** 
 331:rt_thread/src/ipc.c ****     /* parameter check */
 332:rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 404              		.loc 1 332 30 view .LVU122
 333:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 405              		.loc 1 333 84 view .LVU123
 334:rt_thread/src/ipc.c **** 
 335:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
 406              		.loc 1 335 73 view .LVU124
 336:rt_thread/src/ipc.c **** 
 337:rt_thread/src/ipc.c ****     /* disable interrupt */
 338:rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 407              		.loc 1 338 5 view .LVU125
 408              		.loc 1 338 12 is_stmt 0 view .LVU126
 409 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 410              	.LVL39:
 411              		.loc 1 338 12 view .LVU127
 412 000e 0746     		mov	r7, r0
 413              	.LVL40:
 339:rt_thread/src/ipc.c **** 
 340:rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
 341:rt_thread/src/ipc.c ****                                 rt_thread_self()->name,
 342:rt_thread/src/ipc.c ****                                 ((struct rt_object *)sem)->name,
 343:rt_thread/src/ipc.c ****                                 sem->value));
 414              		.loc 1 343 45 is_stmt 1 view .LVU128
 344:rt_thread/src/ipc.c **** 
 345:rt_thread/src/ipc.c ****     if (sem->value > 0)
 415              		.loc 1 345 5 view .LVU129
 416              		.loc 1 345 12 is_stmt 0 view .LVU130
 417 0010 AB8B     		ldrh	r3, [r5, #28]
 418              		.loc 1 345 8 view .LVU131
 419 0012 F3B9     		cbnz	r3, .L27
 346:rt_thread/src/ipc.c ****     {
 347:rt_thread/src/ipc.c ****         /* semaphore is available */
 348:rt_thread/src/ipc.c ****         sem->value --;
 349:rt_thread/src/ipc.c **** 
 350:rt_thread/src/ipc.c ****         /* enable interrupt */
 351:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 352:rt_thread/src/ipc.c ****     }
ARM GAS  /tmp/ccDOLSjn.s 			page 17


 353:rt_thread/src/ipc.c ****     else
 354:rt_thread/src/ipc.c ****     {
 355:rt_thread/src/ipc.c ****         /* no waiting, return with timeout */
 356:rt_thread/src/ipc.c ****         if (time == 0)
 420              		.loc 1 356 9 is_stmt 1 view .LVU132
 421              		.loc 1 356 18 is_stmt 0 view .LVU133
 422 0014 019B     		ldr	r3, [sp, #4]
 423              		.loc 1 356 12 view .LVU134
 424 0016 13B3     		cbz	r3, .L28
 357:rt_thread/src/ipc.c ****         {
 358:rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 359:rt_thread/src/ipc.c **** 
 360:rt_thread/src/ipc.c ****             return -RT_ETIMEOUT;
 361:rt_thread/src/ipc.c ****         }
 362:rt_thread/src/ipc.c ****         else
 363:rt_thread/src/ipc.c ****         {
 364:rt_thread/src/ipc.c ****             /* current context checking */
 365:rt_thread/src/ipc.c ****             RT_DEBUG_IN_THREAD_CONTEXT;
 425              		.loc 1 365 39 is_stmt 1 view .LVU135
 366:rt_thread/src/ipc.c **** 
 367:rt_thread/src/ipc.c ****             /* semaphore is unavailable, push to suspend list */
 368:rt_thread/src/ipc.c ****             /* get current thread */
 369:rt_thread/src/ipc.c ****             thread = rt_thread_self();
 426              		.loc 1 369 13 view .LVU136
 427              		.loc 1 369 22 is_stmt 0 view .LVU137
 428 0018 FFF7FEFF 		bl	rt_thread_self
 429              	.LVL41:
 430              		.loc 1 369 22 view .LVU138
 431 001c 0446     		mov	r4, r0
 432              	.LVL42:
 370:rt_thread/src/ipc.c **** 
 371:rt_thread/src/ipc.c ****             /* reset thread error number */
 372:rt_thread/src/ipc.c ****             thread->error = RT_EOK;
 433              		.loc 1 372 13 is_stmt 1 view .LVU139
 434              		.loc 1 372 27 is_stmt 0 view .LVU140
 435 001e 0023     		movs	r3, #0
 436 0020 0363     		str	r3, [r0, #48]
 373:rt_thread/src/ipc.c **** 
 374:rt_thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
 375:rt_thread/src/ipc.c ****                                         thread->name));
 437              		.loc 1 375 55 is_stmt 1 view .LVU141
 376:rt_thread/src/ipc.c **** 
 377:rt_thread/src/ipc.c ****             /* suspend thread */
 378:rt_thread/src/ipc.c ****             rt_ipc_list_suspend(&(sem->parent.suspend_thread),
 438              		.loc 1 378 13 view .LVU142
 439 0022 05F11406 		add	r6, r5, #20
 440 0026 95F80980 		ldrb	r8, [r5, #9]	@ zero_extendqisi2
 441              	.LVL43:
 442              	.LBB78:
 443              	.LBI78:
  83:rt_thread/src/ipc.c ****                                        struct rt_thread *thread,
 444              		.loc 1 83 20 view .LVU143
 445              	.LBB79:
  88:rt_thread/src/ipc.c **** 
 446              		.loc 1 88 5 view .LVU144
 447 002a FFF7FEFF 		bl	rt_thread_suspend
 448              	.LVL44:
ARM GAS  /tmp/ccDOLSjn.s 			page 18


  90:rt_thread/src/ipc.c ****     {
 449              		.loc 1 90 5 view .LVU145
 450 002e B8F1000F 		cmp	r8, #0
 451 0032 19D0     		beq	.L18
 452 0034 B8F1010F 		cmp	r8, #1
 453 0038 1FD0     		beq	.L19
 454              	.L20:
 128:rt_thread/src/ipc.c **** }
 455              		.loc 1 128 5 view .LVU146
 456              	.LVL45:
 128:rt_thread/src/ipc.c **** }
 457              		.loc 1 128 5 is_stmt 0 view .LVU147
 458              	.LBE79:
 459              	.LBE78:
 379:rt_thread/src/ipc.c ****                                 thread,
 380:rt_thread/src/ipc.c ****                                 sem->parent.parent.flag);
 381:rt_thread/src/ipc.c **** 
 382:rt_thread/src/ipc.c ****             /* has waiting time, start thread timer */
 383:rt_thread/src/ipc.c ****             if (time > 0)
 460              		.loc 1 383 13 is_stmt 1 view .LVU148
 461              		.loc 1 383 22 is_stmt 0 view .LVU149
 462 003a 019B     		ldr	r3, [sp, #4]
 463              		.loc 1 383 16 view .LVU150
 464 003c 002B     		cmp	r3, #0
 465 003e 3ADC     		bgt	.L29
 466              	.LVL46:
 467              	.L25:
 384:rt_thread/src/ipc.c ****             {
 385:rt_thread/src/ipc.c ****                 RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
 386:rt_thread/src/ipc.c ****                                             thread->name));
 387:rt_thread/src/ipc.c **** 
 388:rt_thread/src/ipc.c ****                 /* reset the timeout of thread timer and start it */
 389:rt_thread/src/ipc.c ****                 rt_timer_control(&(thread->thread_timer),
 390:rt_thread/src/ipc.c ****                                  RT_TIMER_CTRL_SET_TIME,
 391:rt_thread/src/ipc.c ****                                  &time);
 392:rt_thread/src/ipc.c ****                 rt_timer_start(&(thread->thread_timer));
 393:rt_thread/src/ipc.c ****             }
 394:rt_thread/src/ipc.c **** 
 395:rt_thread/src/ipc.c ****             /* enable interrupt */
 396:rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 468              		.loc 1 396 13 is_stmt 1 view .LVU151
 469 0040 3846     		mov	r0, r7
 470 0042 FFF7FEFF 		bl	rt_hw_interrupt_enable
 471              	.LVL47:
 397:rt_thread/src/ipc.c **** 
 398:rt_thread/src/ipc.c ****             /* do schedule */
 399:rt_thread/src/ipc.c ****             rt_schedule();
 472              		.loc 1 399 13 view .LVU152
 473 0046 FFF7FEFF 		bl	rt_schedule
 474              	.LVL48:
 400:rt_thread/src/ipc.c **** 
 401:rt_thread/src/ipc.c ****             if (thread->error != RT_EOK)
 475              		.loc 1 401 13 view .LVU153
 476              		.loc 1 401 23 is_stmt 0 view .LVU154
 477 004a 206B     		ldr	r0, [r4, #48]
 478              	.LVL49:
 479              	.L14:
ARM GAS  /tmp/ccDOLSjn.s 			page 19


 402:rt_thread/src/ipc.c ****             {
 403:rt_thread/src/ipc.c ****                 return thread->error;
 404:rt_thread/src/ipc.c ****             }
 405:rt_thread/src/ipc.c ****         }
 406:rt_thread/src/ipc.c ****     }
 407:rt_thread/src/ipc.c **** 
 408:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
 409:rt_thread/src/ipc.c **** 
 410:rt_thread/src/ipc.c ****     return RT_EOK;
 411:rt_thread/src/ipc.c **** }
 480              		.loc 1 411 1 view .LVU155
 481 004c 02B0     		add	sp, sp, #8
 482              	.LCFI6:
 483              		.cfi_remember_state
 484              		.cfi_def_cfa_offset 24
 485              		@ sp needed
 486 004e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 487              	.LVL50:
 488              	.L27:
 489              	.LCFI7:
 490              		.cfi_restore_state
 348:rt_thread/src/ipc.c **** 
 491              		.loc 1 348 9 is_stmt 1 view .LVU156
 348:rt_thread/src/ipc.c **** 
 492              		.loc 1 348 20 is_stmt 0 view .LVU157
 493 0052 013B     		subs	r3, r3, #1
 494 0054 AB83     		strh	r3, [r5, #28]	@ movhi
 351:rt_thread/src/ipc.c ****     }
 495              		.loc 1 351 9 is_stmt 1 view .LVU158
 496 0056 FFF7FEFF 		bl	rt_hw_interrupt_enable
 497              	.LVL51:
 410:rt_thread/src/ipc.c **** }
 498              		.loc 1 410 12 is_stmt 0 view .LVU159
 499 005a 0020     		movs	r0, #0
 500 005c F6E7     		b	.L14
 501              	.LVL52:
 502              	.L28:
 358:rt_thread/src/ipc.c **** 
 503              		.loc 1 358 13 is_stmt 1 view .LVU160
 504 005e FFF7FEFF 		bl	rt_hw_interrupt_enable
 505              	.LVL53:
 360:rt_thread/src/ipc.c ****         }
 506              		.loc 1 360 13 view .LVU161
 360:rt_thread/src/ipc.c ****         }
 507              		.loc 1 360 20 is_stmt 0 view .LVU162
 508 0062 6FF00100 		mvn	r0, #1
 509 0066 F1E7     		b	.L14
 510              	.LVL54:
 511              	.L18:
 512              	.LBB88:
 513              	.LBB87:
  93:rt_thread/src/ipc.c ****         break;
 514              		.loc 1 93 9 is_stmt 1 view .LVU163
 515 0068 04F11403 		add	r3, r4, #20
 516              	.LVL55:
 517              	.LBB80:
 518              	.LBI80:
ARM GAS  /tmp/ccDOLSjn.s 			page 20


  73:rt_thread/include/rtservice.h **** {
 519              		.loc 2 73 16 view .LVU164
 520              	.LBB81:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 521              		.loc 2 75 5 view .LVU165
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 522              		.loc 2 75 6 is_stmt 0 view .LVU166
 523 006c 7268     		ldr	r2, [r6, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 524              		.loc 2 75 19 view .LVU167
 525 006e 1360     		str	r3, [r2]
  76:rt_thread/include/rtservice.h **** 
 526              		.loc 2 76 5 is_stmt 1 view .LVU168
  76:rt_thread/include/rtservice.h **** 
 527              		.loc 2 76 16 is_stmt 0 view .LVU169
 528 0070 7268     		ldr	r2, [r6, #4]
  76:rt_thread/include/rtservice.h **** 
 529              		.loc 2 76 13 view .LVU170
 530 0072 A261     		str	r2, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 531              		.loc 2 78 5 is_stmt 1 view .LVU171
  78:rt_thread/include/rtservice.h ****     n->next = l;
 532              		.loc 2 78 13 is_stmt 0 view .LVU172
 533 0074 7360     		str	r3, [r6, #4]
  79:rt_thread/include/rtservice.h **** }
 534              		.loc 2 79 5 is_stmt 1 view .LVU173
  79:rt_thread/include/rtservice.h **** }
 535              		.loc 2 79 13 is_stmt 0 view .LVU174
 536 0076 6661     		str	r6, [r4, #20]
  80:rt_thread/include/rtservice.h **** 
 537              		.loc 2 80 1 view .LVU175
 538 0078 DFE7     		b	.L20
 539              	.LVL56:
 540              	.L19:
  80:rt_thread/include/rtservice.h **** 
 541              		.loc 2 80 1 view .LVU176
 542              	.LBE81:
 543              	.LBE80:
 544              	.LBB82:
  98:rt_thread/src/ipc.c ****             struct rt_thread *sthread;
 545              		.loc 1 98 13 is_stmt 1 view .LVU177
  99:rt_thread/src/ipc.c **** 
 546              		.loc 1 99 13 view .LVU178
 102:rt_thread/src/ipc.c ****             {
 547              		.loc 1 102 13 view .LVU179
 102:rt_thread/src/ipc.c ****             {
 548              		.loc 1 102 20 is_stmt 0 view .LVU180
 549 007a 6B69     		ldr	r3, [r5, #20]
 550              	.LVL57:
 551              	.L21:
 102:rt_thread/src/ipc.c ****             {
 552              		.loc 1 102 34 is_stmt 1 view .LVU181
 102:rt_thread/src/ipc.c ****             {
 553              		.loc 1 102 13 is_stmt 0 view .LVU182
 554 007c 9E42     		cmp	r6, r3
 555 007e 0FD0     		beq	.L23
 104:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 21


 556              		.loc 1 104 17 is_stmt 1 view .LVU183
 557              	.LVL58:
 107:rt_thread/src/ipc.c ****                 {
 558              		.loc 1 107 17 view .LVU184
 107:rt_thread/src/ipc.c ****                 {
 559              		.loc 1 107 27 is_stmt 0 view .LVU185
 560 0080 94F83510 		ldrb	r1, [r4, #53]	@ zero_extendqisi2
 107:rt_thread/src/ipc.c ****                 {
 561              		.loc 1 107 55 view .LVU186
 562 0084 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 107:rt_thread/src/ipc.c ****                 {
 563              		.loc 1 107 20 view .LVU187
 564 0088 9142     		cmp	r1, r2
 565 008a 01D3     		bcc	.L30
 102:rt_thread/src/ipc.c ****             {
 566              		.loc 1 102 45 is_stmt 1 view .LVU188
 102:rt_thread/src/ipc.c ****             {
 567              		.loc 1 102 47 is_stmt 0 view .LVU189
 568 008c 1B68     		ldr	r3, [r3]
 569              	.LVL59:
 102:rt_thread/src/ipc.c ****             {
 570              		.loc 1 102 47 view .LVU190
 571 008e F5E7     		b	.L21
 572              	.LVL60:
 573              	.L30:
 110:rt_thread/src/ipc.c ****                     break;
 574              		.loc 1 110 21 is_stmt 1 view .LVU191
 575 0090 04F11402 		add	r2, r4, #20
 576              	.LVL61:
 577              	.LBB83:
 578              	.LBI83:
  73:rt_thread/include/rtservice.h **** {
 579              		.loc 2 73 16 view .LVU192
 580              	.LBB84:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 581              		.loc 2 75 5 view .LVU193
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 582              		.loc 2 75 6 is_stmt 0 view .LVU194
 583 0094 5968     		ldr	r1, [r3, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 584              		.loc 2 75 19 view .LVU195
 585 0096 0A60     		str	r2, [r1]
  76:rt_thread/include/rtservice.h **** 
 586              		.loc 2 76 5 is_stmt 1 view .LVU196
  76:rt_thread/include/rtservice.h **** 
 587              		.loc 2 76 16 is_stmt 0 view .LVU197
 588 0098 5968     		ldr	r1, [r3, #4]
  76:rt_thread/include/rtservice.h **** 
 589              		.loc 2 76 13 view .LVU198
 590 009a A161     		str	r1, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 591              		.loc 2 78 5 is_stmt 1 view .LVU199
  78:rt_thread/include/rtservice.h ****     n->next = l;
 592              		.loc 2 78 13 is_stmt 0 view .LVU200
 593 009c 5A60     		str	r2, [r3, #4]
  79:rt_thread/include/rtservice.h **** }
 594              		.loc 2 79 5 is_stmt 1 view .LVU201
ARM GAS  /tmp/ccDOLSjn.s 			page 22


  79:rt_thread/include/rtservice.h **** }
 595              		.loc 2 79 13 is_stmt 0 view .LVU202
 596 009e 6361     		str	r3, [r4, #20]
 597              	.LVL62:
 598              	.L23:
  79:rt_thread/include/rtservice.h **** }
 599              		.loc 2 79 13 view .LVU203
 600              	.LBE84:
 601              	.LBE83:
 119:rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 602              		.loc 1 119 13 is_stmt 1 view .LVU204
 119:rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 603              		.loc 1 119 16 is_stmt 0 view .LVU205
 604 00a0 9E42     		cmp	r6, r3
 605 00a2 CAD1     		bne	.L20
 120:rt_thread/src/ipc.c ****         }
 606              		.loc 1 120 17 is_stmt 1 view .LVU206
 607 00a4 04F11403 		add	r3, r4, #20
 608              	.LVL63:
 609              	.LBB85:
 610              	.LBI85:
  73:rt_thread/include/rtservice.h **** {
 611              		.loc 2 73 16 view .LVU207
 612              	.LBB86:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 613              		.loc 2 75 5 view .LVU208
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 614              		.loc 2 75 6 is_stmt 0 view .LVU209
 615 00a8 7268     		ldr	r2, [r6, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 616              		.loc 2 75 19 view .LVU210
 617 00aa 1360     		str	r3, [r2]
  76:rt_thread/include/rtservice.h **** 
 618              		.loc 2 76 5 is_stmt 1 view .LVU211
  76:rt_thread/include/rtservice.h **** 
 619              		.loc 2 76 16 is_stmt 0 view .LVU212
 620 00ac 7268     		ldr	r2, [r6, #4]
  76:rt_thread/include/rtservice.h **** 
 621              		.loc 2 76 13 view .LVU213
 622 00ae A261     		str	r2, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 623              		.loc 2 78 5 is_stmt 1 view .LVU214
  78:rt_thread/include/rtservice.h ****     n->next = l;
 624              		.loc 2 78 13 is_stmt 0 view .LVU215
 625 00b0 7360     		str	r3, [r6, #4]
  79:rt_thread/include/rtservice.h **** }
 626              		.loc 2 79 5 is_stmt 1 view .LVU216
  79:rt_thread/include/rtservice.h **** }
 627              		.loc 2 79 13 is_stmt 0 view .LVU217
 628 00b2 6661     		str	r6, [r4, #20]
  80:rt_thread/include/rtservice.h **** 
 629              		.loc 2 80 1 view .LVU218
 630 00b4 C1E7     		b	.L20
 631              	.LVL64:
 632              	.L29:
  80:rt_thread/include/rtservice.h **** 
 633              		.loc 2 80 1 view .LVU219
ARM GAS  /tmp/ccDOLSjn.s 			page 23


 634              	.LBE86:
 635              	.LBE85:
 636              	.LBE82:
 637              	.LBE87:
 638              	.LBE88:
 386:rt_thread/src/ipc.c **** 
 639              		.loc 1 386 59 is_stmt 1 view .LVU220
 389:rt_thread/src/ipc.c ****                                  RT_TIMER_CTRL_SET_TIME,
 640              		.loc 1 389 17 view .LVU221
 641 00b6 04F14405 		add	r5, r4, #68
 642              	.LVL65:
 389:rt_thread/src/ipc.c ****                                  RT_TIMER_CTRL_SET_TIME,
 643              		.loc 1 389 17 is_stmt 0 view .LVU222
 644 00ba 01AA     		add	r2, sp, #4
 645 00bc 0021     		movs	r1, #0
 646 00be 2846     		mov	r0, r5
 647 00c0 FFF7FEFF 		bl	rt_timer_control
 648              	.LVL66:
 392:rt_thread/src/ipc.c ****             }
 649              		.loc 1 392 17 is_stmt 1 view .LVU223
 650 00c4 2846     		mov	r0, r5
 651 00c6 FFF7FEFF 		bl	rt_timer_start
 652              	.LVL67:
 653 00ca B9E7     		b	.L25
 654              		.cfi_endproc
 655              	.LFE23:
 657              		.section	.text.rt_sem_trytake,"ax",%progbits
 658              		.align	1
 659              		.global	rt_sem_trytake
 660              		.syntax unified
 661              		.thumb
 662              		.thumb_func
 664              	rt_sem_trytake:
 665              	.LVL68:
 666              	.LFB24:
 412:rt_thread/src/ipc.c **** 
 413:rt_thread/src/ipc.c **** /**
 414:rt_thread/src/ipc.c ****  * This function will try to take a semaphore and immediately return
 415:rt_thread/src/ipc.c ****  *
 416:rt_thread/src/ipc.c ****  * @param sem the semaphore object
 417:rt_thread/src/ipc.c ****  *
 418:rt_thread/src/ipc.c ****  * @return the error code
 419:rt_thread/src/ipc.c ****  */
 420:rt_thread/src/ipc.c **** rt_err_t rt_sem_trytake(rt_sem_t sem)
 421:rt_thread/src/ipc.c **** {
 667              		.loc 1 421 1 view -0
 668              		.cfi_startproc
 669              		@ args = 0, pretend = 0, frame = 0
 670              		@ frame_needed = 0, uses_anonymous_args = 0
 671              		.loc 1 421 1 is_stmt 0 view .LVU225
 672 0000 08B5     		push	{r3, lr}
 673              	.LCFI8:
 674              		.cfi_def_cfa_offset 8
 675              		.cfi_offset 3, -8
 676              		.cfi_offset 14, -4
 422:rt_thread/src/ipc.c ****     return rt_sem_take(sem, 0);
 677              		.loc 1 422 5 is_stmt 1 view .LVU226
ARM GAS  /tmp/ccDOLSjn.s 			page 24


 678              		.loc 1 422 12 is_stmt 0 view .LVU227
 679 0002 0021     		movs	r1, #0
 680 0004 FFF7FEFF 		bl	rt_sem_take
 681              	.LVL69:
 423:rt_thread/src/ipc.c **** }
 682              		.loc 1 423 1 view .LVU228
 683 0008 08BD     		pop	{r3, pc}
 684              		.cfi_endproc
 685              	.LFE24:
 687              		.section	.text.rt_sem_release,"ax",%progbits
 688              		.align	1
 689              		.global	rt_sem_release
 690              		.syntax unified
 691              		.thumb
 692              		.thumb_func
 694              	rt_sem_release:
 695              	.LVL70:
 696              	.LFB25:
 424:rt_thread/src/ipc.c **** 
 425:rt_thread/src/ipc.c **** /**
 426:rt_thread/src/ipc.c ****  * This function will release a semaphore, if there are threads suspended on
 427:rt_thread/src/ipc.c ****  * semaphore, it will be waked up.
 428:rt_thread/src/ipc.c ****  *
 429:rt_thread/src/ipc.c ****  * @param sem the semaphore object
 430:rt_thread/src/ipc.c ****  *
 431:rt_thread/src/ipc.c ****  * @return the error code
 432:rt_thread/src/ipc.c ****  */
 433:rt_thread/src/ipc.c **** rt_err_t rt_sem_release(rt_sem_t sem)
 434:rt_thread/src/ipc.c **** {
 697              		.loc 1 434 1 is_stmt 1 view -0
 698              		.cfi_startproc
 699              		@ args = 0, pretend = 0, frame = 0
 700              		@ frame_needed = 0, uses_anonymous_args = 0
 701              		.loc 1 434 1 is_stmt 0 view .LVU230
 702 0000 38B5     		push	{r3, r4, r5, lr}
 703              	.LCFI9:
 704              		.cfi_def_cfa_offset 16
 705              		.cfi_offset 3, -16
 706              		.cfi_offset 4, -12
 707              		.cfi_offset 5, -8
 708              		.cfi_offset 14, -4
 709 0002 0446     		mov	r4, r0
 435:rt_thread/src/ipc.c ****     register rt_base_t temp;
 710              		.loc 1 435 5 is_stmt 1 view .LVU231
 436:rt_thread/src/ipc.c ****     register rt_bool_t need_schedule;
 711              		.loc 1 436 5 view .LVU232
 437:rt_thread/src/ipc.c **** 
 438:rt_thread/src/ipc.c ****     /* parameter check */
 439:rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 712              		.loc 1 439 30 view .LVU233
 440:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 713              		.loc 1 440 84 view .LVU234
 441:rt_thread/src/ipc.c **** 
 442:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
 714              		.loc 1 442 69 view .LVU235
 443:rt_thread/src/ipc.c **** 
 444:rt_thread/src/ipc.c ****     need_schedule = RT_FALSE;
ARM GAS  /tmp/ccDOLSjn.s 			page 25


 715              		.loc 1 444 5 view .LVU236
 716              	.LVL71:
 445:rt_thread/src/ipc.c **** 
 446:rt_thread/src/ipc.c ****     /* disable interrupt */
 447:rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 717              		.loc 1 447 5 view .LVU237
 718              		.loc 1 447 12 is_stmt 0 view .LVU238
 719 0004 FFF7FEFF 		bl	rt_hw_interrupt_disable
 720              	.LVL72:
 721              		.loc 1 447 12 view .LVU239
 722 0008 0546     		mov	r5, r0
 723              	.LVL73:
 448:rt_thread/src/ipc.c **** 
 449:rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
 450:rt_thread/src/ipc.c ****                                 rt_thread_self()->name,
 451:rt_thread/src/ipc.c ****                                 ((struct rt_object *)sem)->name,
 452:rt_thread/src/ipc.c ****                                 sem->value));
 724              		.loc 1 452 45 is_stmt 1 view .LVU240
 453:rt_thread/src/ipc.c **** 
 454:rt_thread/src/ipc.c ****     if (!rt_list_isempty(&sem->parent.suspend_thread))
 725              		.loc 1 454 5 view .LVU241
 726              		.loc 1 454 26 is_stmt 0 view .LVU242
 727 000a 04F11403 		add	r3, r4, #20
 728              	.LVL74:
 729              	.LBB89:
 730              	.LBI89:
  98:rt_thread/include/rtservice.h **** {
 731              		.loc 2 98 15 is_stmt 1 view .LVU243
 732              	.LBB90:
 733              		.loc 2 100 5 view .LVU244
 734              		.loc 2 100 13 is_stmt 0 view .LVU245
 735 000e 6069     		ldr	r0, [r4, #20]
 736              	.LVL75:
 737              		.loc 2 100 13 view .LVU246
 738              	.LBE90:
 739              	.LBE89:
 740              		.loc 1 454 8 view .LVU247
 741 0010 8342     		cmp	r3, r0
 742 0012 0AD0     		beq	.L34
 455:rt_thread/src/ipc.c ****     {
 456:rt_thread/src/ipc.c ****         /* resume the suspended thread */
 457:rt_thread/src/ipc.c ****         rt_ipc_list_resume(&(sem->parent.suspend_thread));
 743              		.loc 1 457 9 is_stmt 1 view .LVU248
 744              	.LVL76:
 745              	.LBB91:
 746              	.LBI91:
 140:rt_thread/src/ipc.c **** {
 747              		.loc 1 140 20 view .LVU249
 748              	.LBB92:
 142:rt_thread/src/ipc.c **** 
 749              		.loc 1 142 5 view .LVU250
 145:rt_thread/src/ipc.c **** 
 750              		.loc 1 145 5 view .LVU251
 147:rt_thread/src/ipc.c **** 
 751              		.loc 1 147 69 view .LVU252
 150:rt_thread/src/ipc.c **** 
 752              		.loc 1 150 5 view .LVU253
ARM GAS  /tmp/ccDOLSjn.s 			page 26


 753 0014 1438     		subs	r0, r0, #20
 754              	.LVL77:
 150:rt_thread/src/ipc.c **** 
 755              		.loc 1 150 5 is_stmt 0 view .LVU254
 756 0016 FFF7FEFF 		bl	rt_thread_resume
 757              	.LVL78:
 152:rt_thread/src/ipc.c **** }
 758              		.loc 1 152 5 is_stmt 1 view .LVU255
 152:rt_thread/src/ipc.c **** }
 759              		.loc 1 152 5 is_stmt 0 view .LVU256
 760              	.LBE92:
 761              	.LBE91:
 458:rt_thread/src/ipc.c ****         need_schedule = RT_TRUE;
 762              		.loc 1 458 9 is_stmt 1 view .LVU257
 763              		.loc 1 458 23 is_stmt 0 view .LVU258
 764 001a 0124     		movs	r4, #1
 765              	.LVL79:
 766              	.L35:
 459:rt_thread/src/ipc.c ****     }
 460:rt_thread/src/ipc.c ****     else
 461:rt_thread/src/ipc.c ****     {
 462:rt_thread/src/ipc.c ****         if(sem->value < RT_SEM_VALUE_MAX)
 463:rt_thread/src/ipc.c ****         {
 464:rt_thread/src/ipc.c ****             sem->value ++; /* increase value */
 465:rt_thread/src/ipc.c ****         }
 466:rt_thread/src/ipc.c ****         else
 467:rt_thread/src/ipc.c ****         {
 468:rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp); /* enable interrupt */
 469:rt_thread/src/ipc.c ****             return -RT_EFULL; /* value overflowed */
 470:rt_thread/src/ipc.c ****         }
 471:rt_thread/src/ipc.c ****     }
 472:rt_thread/src/ipc.c **** 
 473:rt_thread/src/ipc.c ****     /* enable interrupt */
 474:rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 767              		.loc 1 474 5 is_stmt 1 view .LVU259
 768 001c 2846     		mov	r0, r5
 769 001e FFF7FEFF 		bl	rt_hw_interrupt_enable
 770              	.LVL80:
 475:rt_thread/src/ipc.c **** 
 476:rt_thread/src/ipc.c ****     /* resume a thread, re-schedule */
 477:rt_thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
 771              		.loc 1 477 5 view .LVU260
 772              		.loc 1 477 8 is_stmt 0 view .LVU261
 773 0022 012C     		cmp	r4, #1
 774 0024 10D0     		beq	.L39
 775              	.LVL81:
 776              	.L33:
 478:rt_thread/src/ipc.c ****         rt_schedule();
 479:rt_thread/src/ipc.c **** 
 480:rt_thread/src/ipc.c ****     return RT_EOK;
 481:rt_thread/src/ipc.c **** }
 777              		.loc 1 481 1 view .LVU262
 778 0026 2046     		mov	r0, r4
 779 0028 38BD     		pop	{r3, r4, r5, pc}
 780              	.LVL82:
 781              	.L34:
 462:rt_thread/src/ipc.c ****         {
ARM GAS  /tmp/ccDOLSjn.s 			page 27


 782              		.loc 1 462 9 is_stmt 1 view .LVU263
 462:rt_thread/src/ipc.c ****         {
 783              		.loc 1 462 15 is_stmt 0 view .LVU264
 784 002a A38B     		ldrh	r3, [r4, #28]
 462:rt_thread/src/ipc.c ****         {
 785              		.loc 1 462 11 view .LVU265
 786 002c 4FF6FF72 		movw	r2, #65535
 787 0030 9342     		cmp	r3, r2
 788 0032 03D0     		beq	.L36
 464:rt_thread/src/ipc.c ****         }
 789              		.loc 1 464 13 is_stmt 1 view .LVU266
 464:rt_thread/src/ipc.c ****         }
 790              		.loc 1 464 24 is_stmt 0 view .LVU267
 791 0034 0133     		adds	r3, r3, #1
 792 0036 A383     		strh	r3, [r4, #28]	@ movhi
 444:rt_thread/src/ipc.c **** 
 793              		.loc 1 444 19 view .LVU268
 794 0038 0024     		movs	r4, #0
 795              	.LVL83:
 444:rt_thread/src/ipc.c **** 
 796              		.loc 1 444 19 view .LVU269
 797 003a EFE7     		b	.L35
 798              	.LVL84:
 799              	.L36:
 468:rt_thread/src/ipc.c ****             return -RT_EFULL; /* value overflowed */
 800              		.loc 1 468 13 is_stmt 1 view .LVU270
 801 003c 2846     		mov	r0, r5
 802 003e FFF7FEFF 		bl	rt_hw_interrupt_enable
 803              	.LVL85:
 469:rt_thread/src/ipc.c ****         }
 804              		.loc 1 469 13 view .LVU271
 469:rt_thread/src/ipc.c ****         }
 805              		.loc 1 469 20 is_stmt 0 view .LVU272
 806 0042 6FF00204 		mvn	r4, #2
 807              	.LVL86:
 469:rt_thread/src/ipc.c ****         }
 808              		.loc 1 469 20 view .LVU273
 809 0046 EEE7     		b	.L33
 810              	.LVL87:
 811              	.L39:
 478:rt_thread/src/ipc.c **** 
 812              		.loc 1 478 9 is_stmt 1 view .LVU274
 813 0048 FFF7FEFF 		bl	rt_schedule
 814              	.LVL88:
 480:rt_thread/src/ipc.c **** }
 815              		.loc 1 480 12 is_stmt 0 view .LVU275
 816 004c 0024     		movs	r4, #0
 817              	.LVL89:
 480:rt_thread/src/ipc.c **** }
 818              		.loc 1 480 12 view .LVU276
 819 004e EAE7     		b	.L33
 820              		.cfi_endproc
 821              	.LFE25:
 823              		.section	.text.rt_sem_control,"ax",%progbits
 824              		.align	1
 825              		.global	rt_sem_control
 826              		.syntax unified
ARM GAS  /tmp/ccDOLSjn.s 			page 28


 827              		.thumb
 828              		.thumb_func
 830              	rt_sem_control:
 831              	.LVL90:
 832              	.LFB26:
 482:rt_thread/src/ipc.c **** 
 483:rt_thread/src/ipc.c **** /**
 484:rt_thread/src/ipc.c ****  * This function can get or set some extra attributions of a semaphore object.
 485:rt_thread/src/ipc.c ****  *
 486:rt_thread/src/ipc.c ****  * @param sem the semaphore object
 487:rt_thread/src/ipc.c ****  * @param cmd the execution command
 488:rt_thread/src/ipc.c ****  * @param arg the execution argument
 489:rt_thread/src/ipc.c ****  *
 490:rt_thread/src/ipc.c ****  * @return the error code
 491:rt_thread/src/ipc.c ****  */
 492:rt_thread/src/ipc.c **** rt_err_t rt_sem_control(rt_sem_t sem, int cmd, void *arg)
 493:rt_thread/src/ipc.c **** {
 833              		.loc 1 493 1 is_stmt 1 view -0
 834              		.cfi_startproc
 835              		@ args = 0, pretend = 0, frame = 0
 836              		@ frame_needed = 0, uses_anonymous_args = 0
 494:rt_thread/src/ipc.c ****     rt_ubase_t level;
 837              		.loc 1 494 5 view .LVU278
 495:rt_thread/src/ipc.c **** 
 496:rt_thread/src/ipc.c ****     /* parameter check */
 497:rt_thread/src/ipc.c ****     RT_ASSERT(sem != RT_NULL);
 838              		.loc 1 497 30 view .LVU279
 498:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&sem->parent.parent) == RT_Object_Class_Semaphore);
 839              		.loc 1 498 84 view .LVU280
 499:rt_thread/src/ipc.c **** 
 500:rt_thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
 840              		.loc 1 500 5 view .LVU281
 841              		.loc 1 500 8 is_stmt 0 view .LVU282
 842 0000 0129     		cmp	r1, #1
 843 0002 22D1     		bne	.L44
 493:rt_thread/src/ipc.c ****     rt_ubase_t level;
 844              		.loc 1 493 1 view .LVU283
 845 0004 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 846              	.LCFI10:
 847              		.cfi_def_cfa_offset 24
 848              		.cfi_offset 4, -24
 849              		.cfi_offset 5, -20
 850              		.cfi_offset 6, -16
 851              		.cfi_offset 7, -12
 852              		.cfi_offset 8, -8
 853              		.cfi_offset 14, -4
 854 0008 0646     		mov	r6, r0
 855 000a 1746     		mov	r7, r2
 856              	.LBB98:
 501:rt_thread/src/ipc.c ****     {
 502:rt_thread/src/ipc.c ****         rt_ubase_t value;
 857              		.loc 1 502 9 is_stmt 1 view .LVU284
 503:rt_thread/src/ipc.c **** 
 504:rt_thread/src/ipc.c ****         /* get value */
 505:rt_thread/src/ipc.c ****         value = (rt_ubase_t)arg;
 858              		.loc 1 505 9 view .LVU285
 859              	.LVL91:
ARM GAS  /tmp/ccDOLSjn.s 			page 29


 506:rt_thread/src/ipc.c ****         /* disable interrupt */
 507:rt_thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
 860              		.loc 1 507 9 view .LVU286
 861              		.loc 1 507 17 is_stmt 0 view .LVU287
 862 000c FFF7FEFF 		bl	rt_hw_interrupt_disable
 863              	.LVL92:
 864              		.loc 1 507 17 view .LVU288
 865 0010 8046     		mov	r8, r0
 866              	.LVL93:
 508:rt_thread/src/ipc.c **** 
 509:rt_thread/src/ipc.c ****         /* resume all waiting thread */
 510:rt_thread/src/ipc.c ****         rt_ipc_list_resume_all(&sem->parent.suspend_thread);
 867              		.loc 1 510 9 is_stmt 1 view .LVU289
 868 0012 06F11405 		add	r5, r6, #20
 869              	.LVL94:
 870              	.LBB99:
 871              	.LBI99:
 163:rt_thread/src/ipc.c **** {
 872              		.loc 1 163 20 view .LVU290
 873              	.LBB100:
 165:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 874              		.loc 1 165 5 view .LVU291
 166:rt_thread/src/ipc.c **** 
 875              		.loc 1 166 5 view .LVU292
 169:rt_thread/src/ipc.c ****     {
 876              		.loc 1 169 5 view .LVU293
 169:rt_thread/src/ipc.c ****     {
 877              		.loc 1 169 11 is_stmt 0 view .LVU294
 878 0016 0CE0     		b	.L42
 879              	.LVL95:
 880              	.L43:
 172:rt_thread/src/ipc.c **** 
 881              		.loc 1 172 9 is_stmt 1 view .LVU295
 172:rt_thread/src/ipc.c **** 
 882              		.loc 1 172 16 is_stmt 0 view .LVU296
 883 0018 FFF7FEFF 		bl	rt_hw_interrupt_disable
 884              	.LVL96:
 885 001c 0446     		mov	r4, r0
 886              	.LVL97:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 887              		.loc 1 175 9 is_stmt 1 view .LVU297
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 888              		.loc 1 175 18 is_stmt 0 view .LVU298
 889 001e 2868     		ldr	r0, [r5]
 890              	.LVL98:
 177:rt_thread/src/ipc.c **** 
 891              		.loc 1 177 9 is_stmt 1 view .LVU299
 177:rt_thread/src/ipc.c **** 
 892              		.loc 1 177 23 is_stmt 0 view .LVU300
 893 0020 4FF0FF33 		mov	r3, #-1
 894 0024 C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 895              		.loc 1 184 9 is_stmt 1 view .LVU301
 896 0026 1438     		subs	r0, r0, #20
 897              	.LVL99:
 184:rt_thread/src/ipc.c **** 
 898              		.loc 1 184 9 is_stmt 0 view .LVU302
ARM GAS  /tmp/ccDOLSjn.s 			page 30


 899 0028 FFF7FEFF 		bl	rt_thread_resume
 900              	.LVL100:
 187:rt_thread/src/ipc.c ****     }
 901              		.loc 1 187 9 is_stmt 1 view .LVU303
 902 002c 2046     		mov	r0, r4
 903 002e FFF7FEFF 		bl	rt_hw_interrupt_enable
 904              	.LVL101:
 905              	.L42:
 169:rt_thread/src/ipc.c ****     {
 906              		.loc 1 169 11 view .LVU304
 907              	.LBB101:
 908              	.LBI101:
  98:rt_thread/include/rtservice.h **** {
 909              		.loc 2 98 15 view .LVU305
 910              	.LBB102:
 911              		.loc 2 100 5 view .LVU306
 912              		.loc 2 100 13 is_stmt 0 view .LVU307
 913 0032 2B68     		ldr	r3, [r5]
 914              	.LVL102:
 915              		.loc 2 100 13 view .LVU308
 916              	.LBE102:
 917              	.LBE101:
 169:rt_thread/src/ipc.c ****     {
 918              		.loc 1 169 11 view .LVU309
 919 0034 9D42     		cmp	r5, r3
 920 0036 EFD1     		bne	.L43
 190:rt_thread/src/ipc.c **** }
 921              		.loc 1 190 5 is_stmt 1 view .LVU310
 922              	.LVL103:
 190:rt_thread/src/ipc.c **** }
 923              		.loc 1 190 5 is_stmt 0 view .LVU311
 924              	.LBE100:
 925              	.LBE99:
 511:rt_thread/src/ipc.c **** 
 512:rt_thread/src/ipc.c ****         /* set new value */
 513:rt_thread/src/ipc.c ****         sem->value = (rt_uint16_t)value;
 926              		.loc 1 513 9 is_stmt 1 view .LVU312
 927              		.loc 1 513 20 is_stmt 0 view .LVU313
 928 0038 B783     		strh	r7, [r6, #28]	@ movhi
 514:rt_thread/src/ipc.c **** 
 515:rt_thread/src/ipc.c ****         /* enable interrupt */
 516:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
 929              		.loc 1 516 9 is_stmt 1 view .LVU314
 930 003a 4046     		mov	r0, r8
 931 003c FFF7FEFF 		bl	rt_hw_interrupt_enable
 932              	.LVL104:
 517:rt_thread/src/ipc.c **** 
 518:rt_thread/src/ipc.c ****         rt_schedule();
 933              		.loc 1 518 9 view .LVU315
 934 0040 FFF7FEFF 		bl	rt_schedule
 935              	.LVL105:
 519:rt_thread/src/ipc.c **** 
 520:rt_thread/src/ipc.c ****         return RT_EOK;
 936              		.loc 1 520 9 view .LVU316
 937              		.loc 1 520 16 is_stmt 0 view .LVU317
 938 0044 0020     		movs	r0, #0
 939              	.LBE98:
ARM GAS  /tmp/ccDOLSjn.s 			page 31


 521:rt_thread/src/ipc.c ****     }
 522:rt_thread/src/ipc.c **** 
 523:rt_thread/src/ipc.c ****     return -RT_ERROR;
 524:rt_thread/src/ipc.c **** }
 940              		.loc 1 524 1 view .LVU318
 941 0046 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 942              	.LVL106:
 943              	.L44:
 944              	.LCFI11:
 945              		.cfi_def_cfa_offset 0
 946              		.cfi_restore 4
 947              		.cfi_restore 5
 948              		.cfi_restore 6
 949              		.cfi_restore 7
 950              		.cfi_restore 8
 951              		.cfi_restore 14
 523:rt_thread/src/ipc.c **** }
 952              		.loc 1 523 12 view .LVU319
 953 004a 4FF0FF30 		mov	r0, #-1
 954              	.LVL107:
 955              		.loc 1 524 1 view .LVU320
 956 004e 7047     		bx	lr
 957              		.cfi_endproc
 958              	.LFE26:
 960              		.section	.text.rt_mb_init,"ax",%progbits
 961              		.align	1
 962              		.global	rt_mb_init
 963              		.syntax unified
 964              		.thumb
 965              		.thumb_func
 967              	rt_mb_init:
 968              	.LVL108:
 969              	.LFB27:
 525:rt_thread/src/ipc.c **** #endif /* end of RT_USING_SEMAPHORE */
 526:rt_thread/src/ipc.c **** 
 527:rt_thread/src/ipc.c **** #ifdef RT_USING_MUTEX
 528:rt_thread/src/ipc.c **** /**
 529:rt_thread/src/ipc.c ****  * This function will initialize a mutex and put it under control of resource
 530:rt_thread/src/ipc.c ****  * management.
 531:rt_thread/src/ipc.c ****  *
 532:rt_thread/src/ipc.c ****  * @param mutex the mutex object
 533:rt_thread/src/ipc.c ****  * @param name the name of mutex
 534:rt_thread/src/ipc.c ****  * @param flag the flag of mutex
 535:rt_thread/src/ipc.c ****  *
 536:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 537:rt_thread/src/ipc.c ****  */
 538:rt_thread/src/ipc.c **** rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
 539:rt_thread/src/ipc.c **** {
 540:rt_thread/src/ipc.c ****     /* parameter check */
 541:rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 542:rt_thread/src/ipc.c **** 
 543:rt_thread/src/ipc.c ****     /* initialize object */
 544:rt_thread/src/ipc.c ****     rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
 545:rt_thread/src/ipc.c **** 
 546:rt_thread/src/ipc.c ****     /* initialize ipc object */
 547:rt_thread/src/ipc.c ****     rt_ipc_object_init(&(mutex->parent));
 548:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 32


 549:rt_thread/src/ipc.c ****     mutex->value = 1;
 550:rt_thread/src/ipc.c ****     mutex->owner = RT_NULL;
 551:rt_thread/src/ipc.c ****     mutex->original_priority = 0xFF;
 552:rt_thread/src/ipc.c ****     mutex->hold  = 0;
 553:rt_thread/src/ipc.c **** 
 554:rt_thread/src/ipc.c ****     /* set flag */
 555:rt_thread/src/ipc.c ****     mutex->parent.parent.flag = flag;
 556:rt_thread/src/ipc.c **** 
 557:rt_thread/src/ipc.c ****     return RT_EOK;
 558:rt_thread/src/ipc.c **** }
 559:rt_thread/src/ipc.c **** 
 560:rt_thread/src/ipc.c **** /**
 561:rt_thread/src/ipc.c ****  * This function will detach a mutex from resource management
 562:rt_thread/src/ipc.c ****  *
 563:rt_thread/src/ipc.c ****  * @param mutex the mutex object
 564:rt_thread/src/ipc.c ****  *
 565:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 566:rt_thread/src/ipc.c ****  *
 567:rt_thread/src/ipc.c ****  * @see rt_mutex_delete
 568:rt_thread/src/ipc.c ****  */
 569:rt_thread/src/ipc.c **** rt_err_t rt_mutex_detach(rt_mutex_t mutex)
 570:rt_thread/src/ipc.c **** {
 571:rt_thread/src/ipc.c ****     /* parameter check */
 572:rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 573:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 574:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mutex->parent.parent));
 575:rt_thread/src/ipc.c **** 
 576:rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 577:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
 578:rt_thread/src/ipc.c **** 
 579:rt_thread/src/ipc.c ****     /* detach semaphore object */
 580:rt_thread/src/ipc.c ****     rt_object_detach(&(mutex->parent.parent));
 581:rt_thread/src/ipc.c **** 
 582:rt_thread/src/ipc.c ****     return RT_EOK;
 583:rt_thread/src/ipc.c **** }
 584:rt_thread/src/ipc.c **** 
 585:rt_thread/src/ipc.c **** #ifdef RT_USING_HEAP
 586:rt_thread/src/ipc.c **** /**
 587:rt_thread/src/ipc.c ****  * This function will create a mutex from system resource
 588:rt_thread/src/ipc.c ****  *
 589:rt_thread/src/ipc.c ****  * @param name the name of mutex
 590:rt_thread/src/ipc.c ****  * @param flag the flag of mutex
 591:rt_thread/src/ipc.c ****  *
 592:rt_thread/src/ipc.c ****  * @return the created mutex, RT_NULL on error happen
 593:rt_thread/src/ipc.c ****  *
 594:rt_thread/src/ipc.c ****  * @see rt_mutex_init
 595:rt_thread/src/ipc.c ****  */
 596:rt_thread/src/ipc.c **** rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
 597:rt_thread/src/ipc.c **** {
 598:rt_thread/src/ipc.c ****     struct rt_mutex *mutex;
 599:rt_thread/src/ipc.c **** 
 600:rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 601:rt_thread/src/ipc.c **** 
 602:rt_thread/src/ipc.c ****     /* allocate object */
 603:rt_thread/src/ipc.c ****     mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
 604:rt_thread/src/ipc.c ****     if (mutex == RT_NULL)
 605:rt_thread/src/ipc.c ****         return mutex;
ARM GAS  /tmp/ccDOLSjn.s 			page 33


 606:rt_thread/src/ipc.c **** 
 607:rt_thread/src/ipc.c ****     /* initialize ipc object */
 608:rt_thread/src/ipc.c ****     rt_ipc_object_init(&(mutex->parent));
 609:rt_thread/src/ipc.c **** 
 610:rt_thread/src/ipc.c ****     mutex->value              = 1;
 611:rt_thread/src/ipc.c ****     mutex->owner              = RT_NULL;
 612:rt_thread/src/ipc.c ****     mutex->original_priority  = 0xFF;
 613:rt_thread/src/ipc.c ****     mutex->hold               = 0;
 614:rt_thread/src/ipc.c **** 
 615:rt_thread/src/ipc.c ****     /* set flag */
 616:rt_thread/src/ipc.c ****     mutex->parent.parent.flag = flag;
 617:rt_thread/src/ipc.c **** 
 618:rt_thread/src/ipc.c ****     return mutex;
 619:rt_thread/src/ipc.c **** }
 620:rt_thread/src/ipc.c **** 
 621:rt_thread/src/ipc.c **** /**
 622:rt_thread/src/ipc.c ****  * This function will delete a mutex object and release the memory
 623:rt_thread/src/ipc.c ****  *
 624:rt_thread/src/ipc.c ****  * @param mutex the mutex object
 625:rt_thread/src/ipc.c ****  *
 626:rt_thread/src/ipc.c ****  * @return the error code
 627:rt_thread/src/ipc.c ****  *
 628:rt_thread/src/ipc.c ****  * @see rt_mutex_detach
 629:rt_thread/src/ipc.c ****  */
 630:rt_thread/src/ipc.c **** rt_err_t rt_mutex_delete(rt_mutex_t mutex)
 631:rt_thread/src/ipc.c **** {
 632:rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 633:rt_thread/src/ipc.c **** 
 634:rt_thread/src/ipc.c ****     /* parameter check */
 635:rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 636:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 637:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mutex->parent.parent) == RT_FALSE);
 638:rt_thread/src/ipc.c **** 
 639:rt_thread/src/ipc.c ****     /* wakeup all suspended threads */
 640:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
 641:rt_thread/src/ipc.c **** 
 642:rt_thread/src/ipc.c ****     /* delete mutex object */
 643:rt_thread/src/ipc.c ****     rt_object_delete(&(mutex->parent.parent));
 644:rt_thread/src/ipc.c **** 
 645:rt_thread/src/ipc.c ****     return RT_EOK;
 646:rt_thread/src/ipc.c **** }
 647:rt_thread/src/ipc.c **** #endif
 648:rt_thread/src/ipc.c **** 
 649:rt_thread/src/ipc.c **** /**
 650:rt_thread/src/ipc.c ****  * This function will take a mutex, if the mutex is unavailable, the
 651:rt_thread/src/ipc.c ****  * thread shall wait for a specified time.
 652:rt_thread/src/ipc.c ****  *
 653:rt_thread/src/ipc.c ****  * @param mutex the mutex object
 654:rt_thread/src/ipc.c ****  * @param time the waiting time
 655:rt_thread/src/ipc.c ****  *
 656:rt_thread/src/ipc.c ****  * @return the error code
 657:rt_thread/src/ipc.c ****  */
 658:rt_thread/src/ipc.c **** rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
 659:rt_thread/src/ipc.c **** {
 660:rt_thread/src/ipc.c ****     register rt_base_t temp;
 661:rt_thread/src/ipc.c ****     struct rt_thread *thread;
 662:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 34


 663:rt_thread/src/ipc.c ****     /* this function must not be used in interrupt even if time = 0 */
 664:rt_thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
 665:rt_thread/src/ipc.c **** 
 666:rt_thread/src/ipc.c ****     /* parameter check */
 667:rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 668:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 669:rt_thread/src/ipc.c **** 
 670:rt_thread/src/ipc.c ****     /* get current thread */
 671:rt_thread/src/ipc.c ****     thread = rt_thread_self();
 672:rt_thread/src/ipc.c **** 
 673:rt_thread/src/ipc.c ****     /* disable interrupt */
 674:rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 675:rt_thread/src/ipc.c **** 
 676:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
 677:rt_thread/src/ipc.c **** 
 678:rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC,
 679:rt_thread/src/ipc.c ****                  ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
 680:rt_thread/src/ipc.c ****                   thread->name, mutex->value, mutex->hold));
 681:rt_thread/src/ipc.c **** 
 682:rt_thread/src/ipc.c ****     /* reset thread error */
 683:rt_thread/src/ipc.c ****     thread->error = RT_EOK;
 684:rt_thread/src/ipc.c **** 
 685:rt_thread/src/ipc.c ****     if (mutex->owner == thread)
 686:rt_thread/src/ipc.c ****     {
 687:rt_thread/src/ipc.c ****         if(mutex->hold < RT_MUTEX_HOLD_MAX)
 688:rt_thread/src/ipc.c ****         {
 689:rt_thread/src/ipc.c ****             /* it's the same thread */
 690:rt_thread/src/ipc.c ****             mutex->hold ++;
 691:rt_thread/src/ipc.c ****         }
 692:rt_thread/src/ipc.c ****         else
 693:rt_thread/src/ipc.c ****         {
 694:rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp); /* enable interrupt */
 695:rt_thread/src/ipc.c ****             return -RT_EFULL; /* value overflowed */
 696:rt_thread/src/ipc.c ****         }
 697:rt_thread/src/ipc.c ****     }
 698:rt_thread/src/ipc.c ****     else
 699:rt_thread/src/ipc.c ****     {
 700:rt_thread/src/ipc.c ****         /* The value of mutex is 1 in initial status. Therefore, if the
 701:rt_thread/src/ipc.c ****          * value is great than 0, it indicates the mutex is avaible.
 702:rt_thread/src/ipc.c ****          */
 703:rt_thread/src/ipc.c ****         if (mutex->value > 0)
 704:rt_thread/src/ipc.c ****         {
 705:rt_thread/src/ipc.c ****             /* mutex is available */
 706:rt_thread/src/ipc.c ****             mutex->value --;
 707:rt_thread/src/ipc.c **** 
 708:rt_thread/src/ipc.c ****             /* set mutex owner and original priority */
 709:rt_thread/src/ipc.c ****             mutex->owner             = thread;
 710:rt_thread/src/ipc.c ****             mutex->original_priority = thread->current_priority;
 711:rt_thread/src/ipc.c ****             if(mutex->hold < RT_MUTEX_HOLD_MAX)
 712:rt_thread/src/ipc.c ****             {
 713:rt_thread/src/ipc.c ****                 mutex->hold ++;
 714:rt_thread/src/ipc.c ****             }
 715:rt_thread/src/ipc.c ****             else
 716:rt_thread/src/ipc.c ****             {
 717:rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp); /* enable interrupt */
 718:rt_thread/src/ipc.c ****                 return -RT_EFULL; /* value overflowed */
 719:rt_thread/src/ipc.c ****             }
ARM GAS  /tmp/ccDOLSjn.s 			page 35


 720:rt_thread/src/ipc.c ****         }
 721:rt_thread/src/ipc.c ****         else
 722:rt_thread/src/ipc.c ****         {
 723:rt_thread/src/ipc.c ****             /* no waiting, return with timeout */
 724:rt_thread/src/ipc.c ****             if (time == 0)
 725:rt_thread/src/ipc.c ****             {
 726:rt_thread/src/ipc.c ****                 /* set error as timeout */
 727:rt_thread/src/ipc.c ****                 thread->error = -RT_ETIMEOUT;
 728:rt_thread/src/ipc.c **** 
 729:rt_thread/src/ipc.c ****                 /* enable interrupt */
 730:rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp);
 731:rt_thread/src/ipc.c **** 
 732:rt_thread/src/ipc.c ****                 return -RT_ETIMEOUT;
 733:rt_thread/src/ipc.c ****             }
 734:rt_thread/src/ipc.c ****             else
 735:rt_thread/src/ipc.c ****             {
 736:rt_thread/src/ipc.c ****                 /* mutex is unavailable, push to suspend list */
 737:rt_thread/src/ipc.c ****                 RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
 738:rt_thread/src/ipc.c ****                                             thread->name));
 739:rt_thread/src/ipc.c **** 
 740:rt_thread/src/ipc.c ****                 /* change the owner thread priority of mutex */
 741:rt_thread/src/ipc.c ****                 if (thread->current_priority < mutex->owner->current_priority)
 742:rt_thread/src/ipc.c ****                 {
 743:rt_thread/src/ipc.c ****                     /* change the owner thread priority */
 744:rt_thread/src/ipc.c ****                     rt_thread_control(mutex->owner,
 745:rt_thread/src/ipc.c ****                                       RT_THREAD_CTRL_CHANGE_PRIORITY,
 746:rt_thread/src/ipc.c ****                                       &thread->current_priority);
 747:rt_thread/src/ipc.c ****                 }
 748:rt_thread/src/ipc.c **** 
 749:rt_thread/src/ipc.c ****                 /* suspend current thread */
 750:rt_thread/src/ipc.c ****                 rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
 751:rt_thread/src/ipc.c ****                                     thread,
 752:rt_thread/src/ipc.c ****                                     mutex->parent.parent.flag);
 753:rt_thread/src/ipc.c **** 
 754:rt_thread/src/ipc.c ****                 /* has waiting time, start thread timer */
 755:rt_thread/src/ipc.c ****                 if (time > 0)
 756:rt_thread/src/ipc.c ****                 {
 757:rt_thread/src/ipc.c ****                     RT_DEBUG_LOG(RT_DEBUG_IPC,
 758:rt_thread/src/ipc.c ****                                  ("mutex_take: start the timer of thread:%s\n",
 759:rt_thread/src/ipc.c ****                                   thread->name));
 760:rt_thread/src/ipc.c **** 
 761:rt_thread/src/ipc.c ****                     /* reset the timeout of thread timer and start it */
 762:rt_thread/src/ipc.c ****                     rt_timer_control(&(thread->thread_timer),
 763:rt_thread/src/ipc.c ****                                      RT_TIMER_CTRL_SET_TIME,
 764:rt_thread/src/ipc.c ****                                      &time);
 765:rt_thread/src/ipc.c ****                     rt_timer_start(&(thread->thread_timer));
 766:rt_thread/src/ipc.c ****                 }
 767:rt_thread/src/ipc.c **** 
 768:rt_thread/src/ipc.c ****                 /* enable interrupt */
 769:rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp);
 770:rt_thread/src/ipc.c **** 
 771:rt_thread/src/ipc.c ****                 /* do schedule */
 772:rt_thread/src/ipc.c ****                 rt_schedule();
 773:rt_thread/src/ipc.c **** 
 774:rt_thread/src/ipc.c ****                 if (thread->error != RT_EOK)
 775:rt_thread/src/ipc.c ****                 {
 776:rt_thread/src/ipc.c ****                     /* return error */
ARM GAS  /tmp/ccDOLSjn.s 			page 36


 777:rt_thread/src/ipc.c ****                     return thread->error;
 778:rt_thread/src/ipc.c ****                 }
 779:rt_thread/src/ipc.c ****                 else
 780:rt_thread/src/ipc.c ****                 {
 781:rt_thread/src/ipc.c ****                     /* the mutex is taken successfully. */
 782:rt_thread/src/ipc.c ****                     /* disable interrupt */
 783:rt_thread/src/ipc.c ****                     temp = rt_hw_interrupt_disable();
 784:rt_thread/src/ipc.c ****                 }
 785:rt_thread/src/ipc.c ****             }
 786:rt_thread/src/ipc.c ****         }
 787:rt_thread/src/ipc.c ****     }
 788:rt_thread/src/ipc.c **** 
 789:rt_thread/src/ipc.c ****     /* enable interrupt */
 790:rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 791:rt_thread/src/ipc.c **** 
 792:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
 793:rt_thread/src/ipc.c **** 
 794:rt_thread/src/ipc.c ****     return RT_EOK;
 795:rt_thread/src/ipc.c **** }
 796:rt_thread/src/ipc.c **** 
 797:rt_thread/src/ipc.c **** /**
 798:rt_thread/src/ipc.c ****  * This function will release a mutex, if there are threads suspended on mutex,
 799:rt_thread/src/ipc.c ****  * it will be waked up.
 800:rt_thread/src/ipc.c ****  *
 801:rt_thread/src/ipc.c ****  * @param mutex the mutex object
 802:rt_thread/src/ipc.c ****  *
 803:rt_thread/src/ipc.c ****  * @return the error code
 804:rt_thread/src/ipc.c ****  */
 805:rt_thread/src/ipc.c **** rt_err_t rt_mutex_release(rt_mutex_t mutex)
 806:rt_thread/src/ipc.c **** {
 807:rt_thread/src/ipc.c ****     register rt_base_t temp;
 808:rt_thread/src/ipc.c ****     struct rt_thread *thread;
 809:rt_thread/src/ipc.c ****     rt_bool_t need_schedule;
 810:rt_thread/src/ipc.c **** 
 811:rt_thread/src/ipc.c ****     /* parameter check */
 812:rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 813:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 814:rt_thread/src/ipc.c **** 
 815:rt_thread/src/ipc.c ****     need_schedule = RT_FALSE;
 816:rt_thread/src/ipc.c **** 
 817:rt_thread/src/ipc.c ****     /* only thread could release mutex because we need test the ownership */
 818:rt_thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
 819:rt_thread/src/ipc.c **** 
 820:rt_thread/src/ipc.c ****     /* get current thread */
 821:rt_thread/src/ipc.c ****     thread = rt_thread_self();
 822:rt_thread/src/ipc.c **** 
 823:rt_thread/src/ipc.c ****     /* disable interrupt */
 824:rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 825:rt_thread/src/ipc.c **** 
 826:rt_thread/src/ipc.c ****     RT_DEBUG_LOG(RT_DEBUG_IPC,
 827:rt_thread/src/ipc.c ****                  ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
 828:rt_thread/src/ipc.c ****                   thread->name, mutex->value, mutex->hold));
 829:rt_thread/src/ipc.c **** 
 830:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
 831:rt_thread/src/ipc.c **** 
 832:rt_thread/src/ipc.c ****     /* mutex only can be released by owner */
 833:rt_thread/src/ipc.c ****     if (thread != mutex->owner)
ARM GAS  /tmp/ccDOLSjn.s 			page 37


 834:rt_thread/src/ipc.c ****     {
 835:rt_thread/src/ipc.c ****         thread->error = -RT_ERROR;
 836:rt_thread/src/ipc.c **** 
 837:rt_thread/src/ipc.c ****         /* enable interrupt */
 838:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 839:rt_thread/src/ipc.c **** 
 840:rt_thread/src/ipc.c ****         return -RT_ERROR;
 841:rt_thread/src/ipc.c ****     }
 842:rt_thread/src/ipc.c **** 
 843:rt_thread/src/ipc.c ****     /* decrease hold */
 844:rt_thread/src/ipc.c ****     mutex->hold --;
 845:rt_thread/src/ipc.c ****     /* if no hold */
 846:rt_thread/src/ipc.c ****     if (mutex->hold == 0)
 847:rt_thread/src/ipc.c ****     {
 848:rt_thread/src/ipc.c ****         /* change the owner thread to original priority */
 849:rt_thread/src/ipc.c ****         if (mutex->original_priority != mutex->owner->current_priority)
 850:rt_thread/src/ipc.c ****         {
 851:rt_thread/src/ipc.c ****             rt_thread_control(mutex->owner,
 852:rt_thread/src/ipc.c ****                               RT_THREAD_CTRL_CHANGE_PRIORITY,
 853:rt_thread/src/ipc.c ****                               &(mutex->original_priority));
 854:rt_thread/src/ipc.c ****         }
 855:rt_thread/src/ipc.c **** 
 856:rt_thread/src/ipc.c ****         /* wakeup suspended thread */
 857:rt_thread/src/ipc.c ****         if (!rt_list_isempty(&mutex->parent.suspend_thread))
 858:rt_thread/src/ipc.c ****         {
 859:rt_thread/src/ipc.c ****             /* get suspended thread */
 860:rt_thread/src/ipc.c ****             thread = rt_list_entry(mutex->parent.suspend_thread.next,
 861:rt_thread/src/ipc.c ****                                    struct rt_thread,
 862:rt_thread/src/ipc.c ****                                    tlist);
 863:rt_thread/src/ipc.c **** 
 864:rt_thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
 865:rt_thread/src/ipc.c ****                                         thread->name));
 866:rt_thread/src/ipc.c **** 
 867:rt_thread/src/ipc.c ****             /* set new owner and priority */
 868:rt_thread/src/ipc.c ****             mutex->owner             = thread;
 869:rt_thread/src/ipc.c ****             mutex->original_priority = thread->current_priority;
 870:rt_thread/src/ipc.c ****             if(mutex->hold < RT_MUTEX_HOLD_MAX)
 871:rt_thread/src/ipc.c ****             {
 872:rt_thread/src/ipc.c ****                 mutex->hold ++;
 873:rt_thread/src/ipc.c ****             }
 874:rt_thread/src/ipc.c ****             else
 875:rt_thread/src/ipc.c ****             {
 876:rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp); /* enable interrupt */
 877:rt_thread/src/ipc.c ****                 return -RT_EFULL; /* value overflowed */
 878:rt_thread/src/ipc.c ****             }
 879:rt_thread/src/ipc.c **** 
 880:rt_thread/src/ipc.c ****             /* resume thread */
 881:rt_thread/src/ipc.c ****             rt_ipc_list_resume(&(mutex->parent.suspend_thread));
 882:rt_thread/src/ipc.c **** 
 883:rt_thread/src/ipc.c ****             need_schedule = RT_TRUE;
 884:rt_thread/src/ipc.c ****         }
 885:rt_thread/src/ipc.c ****         else
 886:rt_thread/src/ipc.c ****         {
 887:rt_thread/src/ipc.c ****             if(mutex->value < RT_MUTEX_VALUE_MAX)
 888:rt_thread/src/ipc.c ****             {
 889:rt_thread/src/ipc.c ****                 /* increase value */
 890:rt_thread/src/ipc.c ****                 mutex->value ++;
ARM GAS  /tmp/ccDOLSjn.s 			page 38


 891:rt_thread/src/ipc.c ****             }
 892:rt_thread/src/ipc.c ****             else
 893:rt_thread/src/ipc.c ****             {
 894:rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(temp); /* enable interrupt */
 895:rt_thread/src/ipc.c ****                 return -RT_EFULL; /* value overflowed */
 896:rt_thread/src/ipc.c ****             }
 897:rt_thread/src/ipc.c **** 
 898:rt_thread/src/ipc.c ****             /* clear owner */
 899:rt_thread/src/ipc.c ****             mutex->owner             = RT_NULL;
 900:rt_thread/src/ipc.c ****             mutex->original_priority = 0xff;
 901:rt_thread/src/ipc.c ****         }
 902:rt_thread/src/ipc.c ****     }
 903:rt_thread/src/ipc.c **** 
 904:rt_thread/src/ipc.c ****     /* enable interrupt */
 905:rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
 906:rt_thread/src/ipc.c **** 
 907:rt_thread/src/ipc.c ****     /* perform a schedule */
 908:rt_thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
 909:rt_thread/src/ipc.c ****         rt_schedule();
 910:rt_thread/src/ipc.c **** 
 911:rt_thread/src/ipc.c ****     return RT_EOK;
 912:rt_thread/src/ipc.c **** }
 913:rt_thread/src/ipc.c **** 
 914:rt_thread/src/ipc.c **** /**
 915:rt_thread/src/ipc.c ****  * This function can get or set some extra attributions of a mutex object.
 916:rt_thread/src/ipc.c ****  *
 917:rt_thread/src/ipc.c ****  * @param mutex the mutex object
 918:rt_thread/src/ipc.c ****  * @param cmd the execution command
 919:rt_thread/src/ipc.c ****  * @param arg the execution argument
 920:rt_thread/src/ipc.c ****  *
 921:rt_thread/src/ipc.c ****  * @return the error code
 922:rt_thread/src/ipc.c ****  */
 923:rt_thread/src/ipc.c **** rt_err_t rt_mutex_control(rt_mutex_t mutex, int cmd, void *arg)
 924:rt_thread/src/ipc.c **** {
 925:rt_thread/src/ipc.c ****     /* parameter check */
 926:rt_thread/src/ipc.c ****     RT_ASSERT(mutex != RT_NULL);
 927:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mutex->parent.parent) == RT_Object_Class_Mutex);
 928:rt_thread/src/ipc.c **** 
 929:rt_thread/src/ipc.c ****     return -RT_ERROR;
 930:rt_thread/src/ipc.c **** }
 931:rt_thread/src/ipc.c **** #endif /* end of RT_USING_MUTEX */
 932:rt_thread/src/ipc.c **** 
 933:rt_thread/src/ipc.c **** #ifdef RT_USING_EVENT
 934:rt_thread/src/ipc.c **** /**
 935:rt_thread/src/ipc.c ****  * This function will initialize an event and put it under control of resource
 936:rt_thread/src/ipc.c ****  * management.
 937:rt_thread/src/ipc.c ****  *
 938:rt_thread/src/ipc.c ****  * @param event the event object
 939:rt_thread/src/ipc.c ****  * @param name the name of event
 940:rt_thread/src/ipc.c ****  * @param flag the flag of event
 941:rt_thread/src/ipc.c ****  *
 942:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 943:rt_thread/src/ipc.c ****  */
 944:rt_thread/src/ipc.c **** rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
 945:rt_thread/src/ipc.c **** {
 946:rt_thread/src/ipc.c ****     /* parameter check */
 947:rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
ARM GAS  /tmp/ccDOLSjn.s 			page 39


 948:rt_thread/src/ipc.c **** 
 949:rt_thread/src/ipc.c ****     /* initialize object */
 950:rt_thread/src/ipc.c ****     rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
 951:rt_thread/src/ipc.c **** 
 952:rt_thread/src/ipc.c ****     /* set parent flag */
 953:rt_thread/src/ipc.c ****     event->parent.parent.flag = flag;
 954:rt_thread/src/ipc.c **** 
 955:rt_thread/src/ipc.c ****     /* initialize ipc object */
 956:rt_thread/src/ipc.c ****     rt_ipc_object_init(&(event->parent));
 957:rt_thread/src/ipc.c **** 
 958:rt_thread/src/ipc.c ****     /* initialize event */
 959:rt_thread/src/ipc.c ****     event->set = 0;
 960:rt_thread/src/ipc.c **** 
 961:rt_thread/src/ipc.c ****     return RT_EOK;
 962:rt_thread/src/ipc.c **** }
 963:rt_thread/src/ipc.c **** 
 964:rt_thread/src/ipc.c **** /**
 965:rt_thread/src/ipc.c ****  * This function will detach an event object from resource management
 966:rt_thread/src/ipc.c ****  *
 967:rt_thread/src/ipc.c ****  * @param event the event object
 968:rt_thread/src/ipc.c ****  *
 969:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
 970:rt_thread/src/ipc.c ****  */
 971:rt_thread/src/ipc.c **** rt_err_t rt_event_detach(rt_event_t event)
 972:rt_thread/src/ipc.c **** {
 973:rt_thread/src/ipc.c ****     /* parameter check */
 974:rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
 975:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
 976:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&event->parent.parent));
 977:rt_thread/src/ipc.c **** 
 978:rt_thread/src/ipc.c ****     /* resume all suspended thread */
 979:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(event->parent.suspend_thread));
 980:rt_thread/src/ipc.c **** 
 981:rt_thread/src/ipc.c ****     /* detach event object */
 982:rt_thread/src/ipc.c ****     rt_object_detach(&(event->parent.parent));
 983:rt_thread/src/ipc.c **** 
 984:rt_thread/src/ipc.c ****     return RT_EOK;
 985:rt_thread/src/ipc.c **** }
 986:rt_thread/src/ipc.c **** 
 987:rt_thread/src/ipc.c **** #ifdef RT_USING_HEAP
 988:rt_thread/src/ipc.c **** /**
 989:rt_thread/src/ipc.c ****  * This function will create an event object from system resource
 990:rt_thread/src/ipc.c ****  *
 991:rt_thread/src/ipc.c ****  * @param name the name of event
 992:rt_thread/src/ipc.c ****  * @param flag the flag of event
 993:rt_thread/src/ipc.c ****  *
 994:rt_thread/src/ipc.c ****  * @return the created event, RT_NULL on error happen
 995:rt_thread/src/ipc.c ****  */
 996:rt_thread/src/ipc.c **** rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
 997:rt_thread/src/ipc.c **** {
 998:rt_thread/src/ipc.c ****     rt_event_t event;
 999:rt_thread/src/ipc.c **** 
1000:rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1001:rt_thread/src/ipc.c **** 
1002:rt_thread/src/ipc.c ****     /* allocate object */
1003:rt_thread/src/ipc.c ****     event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
1004:rt_thread/src/ipc.c ****     if (event == RT_NULL)
ARM GAS  /tmp/ccDOLSjn.s 			page 40


1005:rt_thread/src/ipc.c ****         return event;
1006:rt_thread/src/ipc.c **** 
1007:rt_thread/src/ipc.c ****     /* set parent */
1008:rt_thread/src/ipc.c ****     event->parent.parent.flag = flag;
1009:rt_thread/src/ipc.c **** 
1010:rt_thread/src/ipc.c ****     /* initialize ipc object */
1011:rt_thread/src/ipc.c ****     rt_ipc_object_init(&(event->parent));
1012:rt_thread/src/ipc.c **** 
1013:rt_thread/src/ipc.c ****     /* initialize event */
1014:rt_thread/src/ipc.c ****     event->set = 0;
1015:rt_thread/src/ipc.c **** 
1016:rt_thread/src/ipc.c ****     return event;
1017:rt_thread/src/ipc.c **** }
1018:rt_thread/src/ipc.c **** 
1019:rt_thread/src/ipc.c **** /**
1020:rt_thread/src/ipc.c ****  * This function will delete an event object and release the memory
1021:rt_thread/src/ipc.c ****  *
1022:rt_thread/src/ipc.c ****  * @param event the event object
1023:rt_thread/src/ipc.c ****  *
1024:rt_thread/src/ipc.c ****  * @return the error code
1025:rt_thread/src/ipc.c ****  */
1026:rt_thread/src/ipc.c **** rt_err_t rt_event_delete(rt_event_t event)
1027:rt_thread/src/ipc.c **** {
1028:rt_thread/src/ipc.c ****     /* parameter check */
1029:rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1030:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1031:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&event->parent.parent) == RT_FALSE);
1032:rt_thread/src/ipc.c **** 
1033:rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
1034:rt_thread/src/ipc.c **** 
1035:rt_thread/src/ipc.c ****     /* resume all suspended thread */
1036:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(event->parent.suspend_thread));
1037:rt_thread/src/ipc.c **** 
1038:rt_thread/src/ipc.c ****     /* delete event object */
1039:rt_thread/src/ipc.c ****     rt_object_delete(&(event->parent.parent));
1040:rt_thread/src/ipc.c **** 
1041:rt_thread/src/ipc.c ****     return RT_EOK;
1042:rt_thread/src/ipc.c **** }
1043:rt_thread/src/ipc.c **** #endif
1044:rt_thread/src/ipc.c **** 
1045:rt_thread/src/ipc.c **** /**
1046:rt_thread/src/ipc.c ****  * This function will send an event to the event object, if there are threads
1047:rt_thread/src/ipc.c ****  * suspended on event object, it will be waked up.
1048:rt_thread/src/ipc.c ****  *
1049:rt_thread/src/ipc.c ****  * @param event the event object
1050:rt_thread/src/ipc.c ****  * @param set the event set
1051:rt_thread/src/ipc.c ****  *
1052:rt_thread/src/ipc.c ****  * @return the error code
1053:rt_thread/src/ipc.c ****  */
1054:rt_thread/src/ipc.c **** rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
1055:rt_thread/src/ipc.c **** {
1056:rt_thread/src/ipc.c ****     struct rt_list_node *n;
1057:rt_thread/src/ipc.c ****     struct rt_thread *thread;
1058:rt_thread/src/ipc.c ****     register rt_ubase_t level;
1059:rt_thread/src/ipc.c ****     register rt_base_t status;
1060:rt_thread/src/ipc.c ****     rt_bool_t need_schedule;
1061:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 41


1062:rt_thread/src/ipc.c ****     /* parameter check */
1063:rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1064:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1065:rt_thread/src/ipc.c **** 
1066:rt_thread/src/ipc.c ****     if (set == 0)
1067:rt_thread/src/ipc.c ****         return -RT_ERROR;
1068:rt_thread/src/ipc.c **** 
1069:rt_thread/src/ipc.c ****     need_schedule = RT_FALSE;
1070:rt_thread/src/ipc.c **** 
1071:rt_thread/src/ipc.c ****     /* disable interrupt */
1072:rt_thread/src/ipc.c ****     level = rt_hw_interrupt_disable();
1073:rt_thread/src/ipc.c **** 
1074:rt_thread/src/ipc.c ****     /* set event */
1075:rt_thread/src/ipc.c ****     event->set |= set;
1076:rt_thread/src/ipc.c **** 
1077:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
1078:rt_thread/src/ipc.c **** 
1079:rt_thread/src/ipc.c ****     if (!rt_list_isempty(&event->parent.suspend_thread))
1080:rt_thread/src/ipc.c ****     {
1081:rt_thread/src/ipc.c ****         /* search thread list to resume thread */
1082:rt_thread/src/ipc.c ****         n = event->parent.suspend_thread.next;
1083:rt_thread/src/ipc.c ****         while (n != &(event->parent.suspend_thread))
1084:rt_thread/src/ipc.c ****         {
1085:rt_thread/src/ipc.c ****             /* get thread */
1086:rt_thread/src/ipc.c ****             thread = rt_list_entry(n, struct rt_thread, tlist);
1087:rt_thread/src/ipc.c **** 
1088:rt_thread/src/ipc.c ****             status = -RT_ERROR;
1089:rt_thread/src/ipc.c ****             if (thread->event_info & RT_EVENT_FLAG_AND)
1090:rt_thread/src/ipc.c ****             {
1091:rt_thread/src/ipc.c ****                 if ((thread->event_set & event->set) == thread->event_set)
1092:rt_thread/src/ipc.c ****                 {
1093:rt_thread/src/ipc.c ****                     /* received an AND event */
1094:rt_thread/src/ipc.c ****                     status = RT_EOK;
1095:rt_thread/src/ipc.c ****                 }
1096:rt_thread/src/ipc.c ****             }
1097:rt_thread/src/ipc.c ****             else if (thread->event_info & RT_EVENT_FLAG_OR)
1098:rt_thread/src/ipc.c ****             {
1099:rt_thread/src/ipc.c ****                 if (thread->event_set & event->set)
1100:rt_thread/src/ipc.c ****                 {
1101:rt_thread/src/ipc.c ****                     /* save the received event set */
1102:rt_thread/src/ipc.c ****                     thread->event_set = thread->event_set & event->set;
1103:rt_thread/src/ipc.c **** 
1104:rt_thread/src/ipc.c ****                     /* received an OR event */
1105:rt_thread/src/ipc.c ****                     status = RT_EOK;
1106:rt_thread/src/ipc.c ****                 }
1107:rt_thread/src/ipc.c ****             }
1108:rt_thread/src/ipc.c ****             else
1109:rt_thread/src/ipc.c ****             {
1110:rt_thread/src/ipc.c ****                 /* enable interrupt */
1111:rt_thread/src/ipc.c ****                 rt_hw_interrupt_enable(level);
1112:rt_thread/src/ipc.c **** 
1113:rt_thread/src/ipc.c ****                 return -RT_EINVAL;
1114:rt_thread/src/ipc.c ****             }
1115:rt_thread/src/ipc.c **** 
1116:rt_thread/src/ipc.c ****             /* move node to the next */
1117:rt_thread/src/ipc.c ****             n = n->next;
1118:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 42


1119:rt_thread/src/ipc.c ****             /* condition is satisfied, resume thread */
1120:rt_thread/src/ipc.c ****             if (status == RT_EOK)
1121:rt_thread/src/ipc.c ****             {
1122:rt_thread/src/ipc.c ****                 /* clear event */
1123:rt_thread/src/ipc.c ****                 if (thread->event_info & RT_EVENT_FLAG_CLEAR)
1124:rt_thread/src/ipc.c ****                     event->set &= ~thread->event_set;
1125:rt_thread/src/ipc.c **** 
1126:rt_thread/src/ipc.c ****                 /* resume thread, and thread list breaks out */
1127:rt_thread/src/ipc.c ****                 rt_thread_resume(thread);
1128:rt_thread/src/ipc.c **** 
1129:rt_thread/src/ipc.c ****                 /* need do a scheduling */
1130:rt_thread/src/ipc.c ****                 need_schedule = RT_TRUE;
1131:rt_thread/src/ipc.c ****             }
1132:rt_thread/src/ipc.c ****         }
1133:rt_thread/src/ipc.c ****     }
1134:rt_thread/src/ipc.c **** 
1135:rt_thread/src/ipc.c ****     /* enable interrupt */
1136:rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(level);
1137:rt_thread/src/ipc.c **** 
1138:rt_thread/src/ipc.c ****     /* do a schedule */
1139:rt_thread/src/ipc.c ****     if (need_schedule == RT_TRUE)
1140:rt_thread/src/ipc.c ****         rt_schedule();
1141:rt_thread/src/ipc.c **** 
1142:rt_thread/src/ipc.c ****     return RT_EOK;
1143:rt_thread/src/ipc.c **** }
1144:rt_thread/src/ipc.c **** 
1145:rt_thread/src/ipc.c **** /**
1146:rt_thread/src/ipc.c ****  * This function will receive an event from event object, if the event is
1147:rt_thread/src/ipc.c ****  * unavailable, the thread shall wait for a specified time.
1148:rt_thread/src/ipc.c ****  *
1149:rt_thread/src/ipc.c ****  * @param event the fast event object
1150:rt_thread/src/ipc.c ****  * @param set the interested event set
1151:rt_thread/src/ipc.c ****  * @param option the receive option, either RT_EVENT_FLAG_AND or
1152:rt_thread/src/ipc.c ****  *        RT_EVENT_FLAG_OR should be set.
1153:rt_thread/src/ipc.c ****  * @param timeout the waiting time
1154:rt_thread/src/ipc.c ****  * @param recved the received event, if you don't care, RT_NULL can be set.
1155:rt_thread/src/ipc.c ****  *
1156:rt_thread/src/ipc.c ****  * @return the error code
1157:rt_thread/src/ipc.c ****  */
1158:rt_thread/src/ipc.c **** rt_err_t rt_event_recv(rt_event_t   event,
1159:rt_thread/src/ipc.c ****                        rt_uint32_t  set,
1160:rt_thread/src/ipc.c ****                        rt_uint8_t   option,
1161:rt_thread/src/ipc.c ****                        rt_int32_t   timeout,
1162:rt_thread/src/ipc.c ****                        rt_uint32_t *recved)
1163:rt_thread/src/ipc.c **** {
1164:rt_thread/src/ipc.c ****     struct rt_thread *thread;
1165:rt_thread/src/ipc.c ****     register rt_ubase_t level;
1166:rt_thread/src/ipc.c ****     register rt_base_t status;
1167:rt_thread/src/ipc.c **** 
1168:rt_thread/src/ipc.c ****     RT_DEBUG_IN_THREAD_CONTEXT;
1169:rt_thread/src/ipc.c **** 
1170:rt_thread/src/ipc.c ****     /* parameter check */
1171:rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1172:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1173:rt_thread/src/ipc.c **** 
1174:rt_thread/src/ipc.c ****     if (set == 0)
1175:rt_thread/src/ipc.c ****         return -RT_ERROR;
ARM GAS  /tmp/ccDOLSjn.s 			page 43


1176:rt_thread/src/ipc.c **** 
1177:rt_thread/src/ipc.c ****     /* initialize status */
1178:rt_thread/src/ipc.c ****     status = -RT_ERROR;
1179:rt_thread/src/ipc.c ****     /* get current thread */
1180:rt_thread/src/ipc.c ****     thread = rt_thread_self();
1181:rt_thread/src/ipc.c ****     /* reset thread error */
1182:rt_thread/src/ipc.c ****     thread->error = RT_EOK;
1183:rt_thread/src/ipc.c **** 
1184:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
1185:rt_thread/src/ipc.c **** 
1186:rt_thread/src/ipc.c ****     /* disable interrupt */
1187:rt_thread/src/ipc.c ****     level = rt_hw_interrupt_disable();
1188:rt_thread/src/ipc.c **** 
1189:rt_thread/src/ipc.c ****     /* check event set */
1190:rt_thread/src/ipc.c ****     if (option & RT_EVENT_FLAG_AND)
1191:rt_thread/src/ipc.c ****     {
1192:rt_thread/src/ipc.c ****         if ((event->set & set) == set)
1193:rt_thread/src/ipc.c ****             status = RT_EOK;
1194:rt_thread/src/ipc.c ****     }
1195:rt_thread/src/ipc.c ****     else if (option & RT_EVENT_FLAG_OR)
1196:rt_thread/src/ipc.c ****     {
1197:rt_thread/src/ipc.c ****         if (event->set & set)
1198:rt_thread/src/ipc.c ****             status = RT_EOK;
1199:rt_thread/src/ipc.c ****     }
1200:rt_thread/src/ipc.c ****     else
1201:rt_thread/src/ipc.c ****     {
1202:rt_thread/src/ipc.c ****         /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
1203:rt_thread/src/ipc.c ****         RT_ASSERT(0);
1204:rt_thread/src/ipc.c ****     }
1205:rt_thread/src/ipc.c **** 
1206:rt_thread/src/ipc.c ****     if (status == RT_EOK)
1207:rt_thread/src/ipc.c ****     {
1208:rt_thread/src/ipc.c ****         /* set received event */
1209:rt_thread/src/ipc.c ****         if (recved)
1210:rt_thread/src/ipc.c ****             *recved = (event->set & set);
1211:rt_thread/src/ipc.c **** 
1212:rt_thread/src/ipc.c ****         /* fill thread event info */
1213:rt_thread/src/ipc.c ****         thread->event_set = (event->set & set);
1214:rt_thread/src/ipc.c ****         thread->event_info = option;
1215:rt_thread/src/ipc.c **** 
1216:rt_thread/src/ipc.c ****         /* received event */
1217:rt_thread/src/ipc.c ****         if (option & RT_EVENT_FLAG_CLEAR)
1218:rt_thread/src/ipc.c ****             event->set &= ~set;
1219:rt_thread/src/ipc.c ****     }
1220:rt_thread/src/ipc.c ****     else if (timeout == 0)
1221:rt_thread/src/ipc.c ****     {
1222:rt_thread/src/ipc.c ****         /* no waiting */
1223:rt_thread/src/ipc.c ****         thread->error = -RT_ETIMEOUT;
1224:rt_thread/src/ipc.c **** 
1225:rt_thread/src/ipc.c ****         /* enable interrupt */
1226:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
1227:rt_thread/src/ipc.c **** 
1228:rt_thread/src/ipc.c ****         return -RT_ETIMEOUT;
1229:rt_thread/src/ipc.c ****     }
1230:rt_thread/src/ipc.c ****     else
1231:rt_thread/src/ipc.c ****     {
1232:rt_thread/src/ipc.c ****         /* fill thread event info */
ARM GAS  /tmp/ccDOLSjn.s 			page 44


1233:rt_thread/src/ipc.c ****         thread->event_set  = set;
1234:rt_thread/src/ipc.c ****         thread->event_info = option;
1235:rt_thread/src/ipc.c **** 
1236:rt_thread/src/ipc.c ****         /* put thread to suspended thread list */
1237:rt_thread/src/ipc.c ****         rt_ipc_list_suspend(&(event->parent.suspend_thread),
1238:rt_thread/src/ipc.c ****                             thread,
1239:rt_thread/src/ipc.c ****                             event->parent.parent.flag);
1240:rt_thread/src/ipc.c **** 
1241:rt_thread/src/ipc.c ****         /* if there is a waiting timeout, active thread timer */
1242:rt_thread/src/ipc.c ****         if (timeout > 0)
1243:rt_thread/src/ipc.c ****         {
1244:rt_thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
1245:rt_thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
1246:rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1247:rt_thread/src/ipc.c ****                              &timeout);
1248:rt_thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
1249:rt_thread/src/ipc.c ****         }
1250:rt_thread/src/ipc.c **** 
1251:rt_thread/src/ipc.c ****         /* enable interrupt */
1252:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
1253:rt_thread/src/ipc.c **** 
1254:rt_thread/src/ipc.c ****         /* do a schedule */
1255:rt_thread/src/ipc.c ****         rt_schedule();
1256:rt_thread/src/ipc.c **** 
1257:rt_thread/src/ipc.c ****         if (thread->error != RT_EOK)
1258:rt_thread/src/ipc.c ****         {
1259:rt_thread/src/ipc.c ****             /* return error */
1260:rt_thread/src/ipc.c ****             return thread->error;
1261:rt_thread/src/ipc.c ****         }
1262:rt_thread/src/ipc.c **** 
1263:rt_thread/src/ipc.c ****         /* received an event, disable interrupt to protect */
1264:rt_thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
1265:rt_thread/src/ipc.c **** 
1266:rt_thread/src/ipc.c ****         /* set received event */
1267:rt_thread/src/ipc.c ****         if (recved)
1268:rt_thread/src/ipc.c ****             *recved = thread->event_set;
1269:rt_thread/src/ipc.c ****     }
1270:rt_thread/src/ipc.c **** 
1271:rt_thread/src/ipc.c ****     /* enable interrupt */
1272:rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(level);
1273:rt_thread/src/ipc.c **** 
1274:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
1275:rt_thread/src/ipc.c **** 
1276:rt_thread/src/ipc.c ****     return thread->error;
1277:rt_thread/src/ipc.c **** }
1278:rt_thread/src/ipc.c **** 
1279:rt_thread/src/ipc.c **** /**
1280:rt_thread/src/ipc.c ****  * This function can get or set some extra attributions of an event object.
1281:rt_thread/src/ipc.c ****  *
1282:rt_thread/src/ipc.c ****  * @param event the event object
1283:rt_thread/src/ipc.c ****  * @param cmd the execution command
1284:rt_thread/src/ipc.c ****  * @param arg the execution argument
1285:rt_thread/src/ipc.c ****  *
1286:rt_thread/src/ipc.c ****  * @return the error code
1287:rt_thread/src/ipc.c ****  */
1288:rt_thread/src/ipc.c **** rt_err_t rt_event_control(rt_event_t event, int cmd, void *arg)
1289:rt_thread/src/ipc.c **** {
ARM GAS  /tmp/ccDOLSjn.s 			page 45


1290:rt_thread/src/ipc.c ****     rt_ubase_t level;
1291:rt_thread/src/ipc.c **** 
1292:rt_thread/src/ipc.c ****     /* parameter check */
1293:rt_thread/src/ipc.c ****     RT_ASSERT(event != RT_NULL);
1294:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&event->parent.parent) == RT_Object_Class_Event);
1295:rt_thread/src/ipc.c **** 
1296:rt_thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
1297:rt_thread/src/ipc.c ****     {
1298:rt_thread/src/ipc.c ****         /* disable interrupt */
1299:rt_thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
1300:rt_thread/src/ipc.c **** 
1301:rt_thread/src/ipc.c ****         /* resume all waiting thread */
1302:rt_thread/src/ipc.c ****         rt_ipc_list_resume_all(&event->parent.suspend_thread);
1303:rt_thread/src/ipc.c **** 
1304:rt_thread/src/ipc.c ****         /* initialize event set */
1305:rt_thread/src/ipc.c ****         event->set = 0;
1306:rt_thread/src/ipc.c **** 
1307:rt_thread/src/ipc.c ****         /* enable interrupt */
1308:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
1309:rt_thread/src/ipc.c **** 
1310:rt_thread/src/ipc.c ****         rt_schedule();
1311:rt_thread/src/ipc.c **** 
1312:rt_thread/src/ipc.c ****         return RT_EOK;
1313:rt_thread/src/ipc.c ****     }
1314:rt_thread/src/ipc.c **** 
1315:rt_thread/src/ipc.c ****     return -RT_ERROR;
1316:rt_thread/src/ipc.c **** }
1317:rt_thread/src/ipc.c **** #endif /* end of RT_USING_EVENT */
1318:rt_thread/src/ipc.c **** 
1319:rt_thread/src/ipc.c **** #ifdef RT_USING_MAILBOX
1320:rt_thread/src/ipc.c **** /**
1321:rt_thread/src/ipc.c ****  * This function will initialize a mailbox and put it under control of resource
1322:rt_thread/src/ipc.c ****  * management.
1323:rt_thread/src/ipc.c ****  *
1324:rt_thread/src/ipc.c ****  * @param mb the mailbox object
1325:rt_thread/src/ipc.c ****  * @param name the name of mailbox
1326:rt_thread/src/ipc.c ****  * @param msgpool the begin address of buffer to save received mail
1327:rt_thread/src/ipc.c ****  * @param size the size of mailbox
1328:rt_thread/src/ipc.c ****  * @param flag the flag of mailbox
1329:rt_thread/src/ipc.c ****  *
1330:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
1331:rt_thread/src/ipc.c ****  */
1332:rt_thread/src/ipc.c **** rt_err_t rt_mb_init(rt_mailbox_t mb,
1333:rt_thread/src/ipc.c ****                     const char  *name,
1334:rt_thread/src/ipc.c ****                     void        *msgpool,
1335:rt_thread/src/ipc.c ****                     rt_size_t    size,
1336:rt_thread/src/ipc.c ****                     rt_uint8_t   flag)
1337:rt_thread/src/ipc.c **** {
 970              		.loc 1 1337 1 is_stmt 1 view -0
 971              		.cfi_startproc
 972              		@ args = 4, pretend = 0, frame = 0
 973              		@ frame_needed = 0, uses_anonymous_args = 0
 974              		.loc 1 1337 1 is_stmt 0 view .LVU322
 975 0000 70B5     		push	{r4, r5, r6, lr}
 976              	.LCFI12:
 977              		.cfi_def_cfa_offset 16
 978              		.cfi_offset 4, -16
ARM GAS  /tmp/ccDOLSjn.s 			page 46


 979              		.cfi_offset 5, -12
 980              		.cfi_offset 6, -8
 981              		.cfi_offset 14, -4
 982 0002 0446     		mov	r4, r0
 983 0004 1646     		mov	r6, r2
 984 0006 1D46     		mov	r5, r3
1338:rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
 985              		.loc 1 1338 29 is_stmt 1 view .LVU323
1339:rt_thread/src/ipc.c **** 
1340:rt_thread/src/ipc.c ****     /* initialize object */
1341:rt_thread/src/ipc.c ****     rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
 986              		.loc 1 1341 5 view .LVU324
 987 0008 0A46     		mov	r2, r1
 988              	.LVL109:
 989              		.loc 1 1341 5 is_stmt 0 view .LVU325
 990 000a 0521     		movs	r1, #5
 991              	.LVL110:
 992              		.loc 1 1341 5 view .LVU326
 993 000c FFF7FEFF 		bl	rt_object_init
 994              	.LVL111:
1342:rt_thread/src/ipc.c **** 
1343:rt_thread/src/ipc.c ****     /* set parent flag */
1344:rt_thread/src/ipc.c ****     mb->parent.parent.flag = flag;
 995              		.loc 1 1344 5 is_stmt 1 view .LVU327
 996              		.loc 1 1344 28 is_stmt 0 view .LVU328
 997 0010 9DF81030 		ldrb	r3, [sp, #16]	@ zero_extendqisi2
 998 0014 6372     		strb	r3, [r4, #9]
1345:rt_thread/src/ipc.c **** 
1346:rt_thread/src/ipc.c ****     /* initialize ipc object */
1347:rt_thread/src/ipc.c ****     rt_ipc_object_init(&(mb->parent));
 999              		.loc 1 1347 5 is_stmt 1 view .LVU329
 1000              	.LVL112:
 1001              	.LBB103:
 1002              	.LBI103:
  64:rt_thread/src/ipc.c **** {
 1003              		.loc 1 64 20 view .LVU330
 1004              	.LBB104:
  67:rt_thread/src/ipc.c **** 
 1005              		.loc 1 67 5 view .LVU331
 1006 0016 04F11403 		add	r3, r4, #20
 1007              	.LVL113:
 1008              	.LBB105:
 1009              	.LBI105:
  47:rt_thread/include/rtservice.h **** {
 1010              		.loc 2 47 16 view .LVU332
 1011              	.LBB106:
  49:rt_thread/include/rtservice.h **** }
 1012              		.loc 2 49 5 view .LVU333
  49:rt_thread/include/rtservice.h **** }
 1013              		.loc 2 49 23 is_stmt 0 view .LVU334
 1014 001a A361     		str	r3, [r4, #24]
  49:rt_thread/include/rtservice.h **** }
 1015              		.loc 2 49 13 view .LVU335
 1016 001c 6361     		str	r3, [r4, #20]
 1017              	.LVL114:
  49:rt_thread/include/rtservice.h **** }
 1018              		.loc 2 49 13 view .LVU336
ARM GAS  /tmp/ccDOLSjn.s 			page 47


 1019              	.LBE106:
 1020              	.LBE105:
  69:rt_thread/src/ipc.c **** }
 1021              		.loc 1 69 5 is_stmt 1 view .LVU337
  69:rt_thread/src/ipc.c **** }
 1022              		.loc 1 69 5 is_stmt 0 view .LVU338
 1023              	.LBE104:
 1024              	.LBE103:
1348:rt_thread/src/ipc.c **** 
1349:rt_thread/src/ipc.c ****     /* initialize mailbox */
1350:rt_thread/src/ipc.c ****     mb->msg_pool   = (rt_ubase_t *)msgpool;
 1025              		.loc 1 1350 5 is_stmt 1 view .LVU339
 1026              		.loc 1 1350 20 is_stmt 0 view .LVU340
 1027 001e E661     		str	r6, [r4, #28]
1351:rt_thread/src/ipc.c ****     mb->size       = size;
 1028              		.loc 1 1351 5 is_stmt 1 view .LVU341
 1029              		.loc 1 1351 20 is_stmt 0 view .LVU342
 1030 0020 2584     		strh	r5, [r4, #32]	@ movhi
1352:rt_thread/src/ipc.c ****     mb->entry      = 0;
 1031              		.loc 1 1352 5 is_stmt 1 view .LVU343
 1032              		.loc 1 1352 20 is_stmt 0 view .LVU344
 1033 0022 0020     		movs	r0, #0
 1034 0024 6084     		strh	r0, [r4, #34]	@ movhi
1353:rt_thread/src/ipc.c ****     mb->in_offset  = 0;
 1035              		.loc 1 1353 5 is_stmt 1 view .LVU345
 1036              		.loc 1 1353 20 is_stmt 0 view .LVU346
 1037 0026 A084     		strh	r0, [r4, #36]	@ movhi
1354:rt_thread/src/ipc.c ****     mb->out_offset = 0;
 1038              		.loc 1 1354 5 is_stmt 1 view .LVU347
 1039              		.loc 1 1354 20 is_stmt 0 view .LVU348
 1040 0028 E084     		strh	r0, [r4, #38]	@ movhi
1355:rt_thread/src/ipc.c **** 
1356:rt_thread/src/ipc.c ****     /* initialize an additional list of sender suspend thread */
1357:rt_thread/src/ipc.c ****     rt_list_init(&(mb->suspend_sender_thread));
 1041              		.loc 1 1357 5 is_stmt 1 view .LVU349
 1042 002a 04F12803 		add	r3, r4, #40
 1043              	.LVL115:
 1044              	.LBB107:
 1045              	.LBI107:
  47:rt_thread/include/rtservice.h **** {
 1046              		.loc 2 47 16 view .LVU350
 1047              	.LBB108:
  49:rt_thread/include/rtservice.h **** }
 1048              		.loc 2 49 5 view .LVU351
  49:rt_thread/include/rtservice.h **** }
 1049              		.loc 2 49 23 is_stmt 0 view .LVU352
 1050 002e E362     		str	r3, [r4, #44]
  49:rt_thread/include/rtservice.h **** }
 1051              		.loc 2 49 13 view .LVU353
 1052 0030 A362     		str	r3, [r4, #40]
 1053              	.LVL116:
  49:rt_thread/include/rtservice.h **** }
 1054              		.loc 2 49 13 view .LVU354
 1055              	.LBE108:
 1056              	.LBE107:
1358:rt_thread/src/ipc.c **** 
1359:rt_thread/src/ipc.c ****     return RT_EOK;
ARM GAS  /tmp/ccDOLSjn.s 			page 48


 1057              		.loc 1 1359 5 is_stmt 1 view .LVU355
1360:rt_thread/src/ipc.c **** }
 1058              		.loc 1 1360 1 is_stmt 0 view .LVU356
 1059 0032 70BD     		pop	{r4, r5, r6, pc}
 1060              		.loc 1 1360 1 view .LVU357
 1061              		.cfi_endproc
 1062              	.LFE27:
 1064              		.section	.text.rt_mb_detach,"ax",%progbits
 1065              		.align	1
 1066              		.global	rt_mb_detach
 1067              		.syntax unified
 1068              		.thumb
 1069              		.thumb_func
 1071              	rt_mb_detach:
 1072              	.LVL117:
 1073              	.LFB28:
1361:rt_thread/src/ipc.c **** 
1362:rt_thread/src/ipc.c **** /**
1363:rt_thread/src/ipc.c ****  * This function will detach a mailbox from resource management
1364:rt_thread/src/ipc.c ****  *
1365:rt_thread/src/ipc.c ****  * @param mb the mailbox object
1366:rt_thread/src/ipc.c ****  *
1367:rt_thread/src/ipc.c ****  * @return the operation status, RT_EOK on successful
1368:rt_thread/src/ipc.c ****  */
1369:rt_thread/src/ipc.c **** rt_err_t rt_mb_detach(rt_mailbox_t mb)
1370:rt_thread/src/ipc.c **** {
 1074              		.loc 1 1370 1 is_stmt 1 view -0
 1075              		.cfi_startproc
 1076              		@ args = 0, pretend = 0, frame = 0
 1077              		@ frame_needed = 0, uses_anonymous_args = 0
 1078              		.loc 1 1370 1 is_stmt 0 view .LVU359
 1079 0000 70B5     		push	{r4, r5, r6, lr}
 1080              	.LCFI13:
 1081              		.cfi_def_cfa_offset 16
 1082              		.cfi_offset 4, -16
 1083              		.cfi_offset 5, -12
 1084              		.cfi_offset 6, -8
 1085              		.cfi_offset 14, -4
 1086 0002 0646     		mov	r6, r0
1371:rt_thread/src/ipc.c ****     /* parameter check */
1372:rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
 1087              		.loc 1 1372 29 is_stmt 1 view .LVU360
1373:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
 1088              		.loc 1 1373 81 view .LVU361
1374:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mb->parent.parent));
 1089              		.loc 1 1374 61 view .LVU362
1375:rt_thread/src/ipc.c **** 
1376:rt_thread/src/ipc.c ****     /* resume all suspended thread */
1377:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
 1090              		.loc 1 1377 5 view .LVU363
 1091 0004 00F11405 		add	r5, r0, #20
 1092              	.LVL118:
 1093              	.LBB117:
 1094              	.LBI117:
 163:rt_thread/src/ipc.c **** {
 1095              		.loc 1 163 20 view .LVU364
 1096              	.LBB118:
ARM GAS  /tmp/ccDOLSjn.s 			page 49


 165:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 1097              		.loc 1 165 5 view .LVU365
 166:rt_thread/src/ipc.c **** 
 1098              		.loc 1 166 5 view .LVU366
 169:rt_thread/src/ipc.c ****     {
 1099              		.loc 1 169 5 view .LVU367
 169:rt_thread/src/ipc.c ****     {
 1100              		.loc 1 169 11 is_stmt 0 view .LVU368
 1101 0008 0CE0     		b	.L52
 1102              	.LVL119:
 1103              	.L53:
 172:rt_thread/src/ipc.c **** 
 1104              		.loc 1 172 9 is_stmt 1 view .LVU369
 172:rt_thread/src/ipc.c **** 
 1105              		.loc 1 172 16 is_stmt 0 view .LVU370
 1106 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 1107              	.LVL120:
 1108 000e 0446     		mov	r4, r0
 1109              	.LVL121:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1110              		.loc 1 175 9 is_stmt 1 view .LVU371
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1111              		.loc 1 175 18 is_stmt 0 view .LVU372
 1112 0010 2868     		ldr	r0, [r5]
 1113              	.LVL122:
 177:rt_thread/src/ipc.c **** 
 1114              		.loc 1 177 9 is_stmt 1 view .LVU373
 177:rt_thread/src/ipc.c **** 
 1115              		.loc 1 177 23 is_stmt 0 view .LVU374
 1116 0012 4FF0FF33 		mov	r3, #-1
 1117 0016 C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 1118              		.loc 1 184 9 is_stmt 1 view .LVU375
 1119 0018 1438     		subs	r0, r0, #20
 1120              	.LVL123:
 184:rt_thread/src/ipc.c **** 
 1121              		.loc 1 184 9 is_stmt 0 view .LVU376
 1122 001a FFF7FEFF 		bl	rt_thread_resume
 1123              	.LVL124:
 187:rt_thread/src/ipc.c ****     }
 1124              		.loc 1 187 9 is_stmt 1 view .LVU377
 1125 001e 2046     		mov	r0, r4
 1126 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1127              	.LVL125:
 1128              	.L52:
 169:rt_thread/src/ipc.c ****     {
 1129              		.loc 1 169 11 view .LVU378
 1130              	.LBB119:
 1131              	.LBI119:
  98:rt_thread/include/rtservice.h **** {
 1132              		.loc 2 98 15 view .LVU379
 1133              	.LBB120:
 1134              		.loc 2 100 5 view .LVU380
 1135              		.loc 2 100 13 is_stmt 0 view .LVU381
 1136 0024 2B68     		ldr	r3, [r5]
 1137              	.LVL126:
 1138              		.loc 2 100 13 view .LVU382
ARM GAS  /tmp/ccDOLSjn.s 			page 50


 1139              	.LBE120:
 1140              	.LBE119:
 169:rt_thread/src/ipc.c ****     {
 1141              		.loc 1 169 11 view .LVU383
 1142 0026 9D42     		cmp	r5, r3
 1143 0028 EFD1     		bne	.L53
 190:rt_thread/src/ipc.c **** }
 1144              		.loc 1 190 5 is_stmt 1 view .LVU384
 1145              	.LVL127:
 190:rt_thread/src/ipc.c **** }
 1146              		.loc 1 190 5 is_stmt 0 view .LVU385
 1147              	.LBE118:
 1148              	.LBE117:
1378:rt_thread/src/ipc.c ****     /* also resume all mailbox private suspended thread */
1379:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
 1149              		.loc 1 1379 5 is_stmt 1 view .LVU386
 1150 002a 06F12805 		add	r5, r6, #40
 1151              	.LVL128:
 1152              	.LBB121:
 1153              	.LBI121:
 163:rt_thread/src/ipc.c **** {
 1154              		.loc 1 163 20 view .LVU387
 1155 002e 0CE0     		b	.L54
 1156              	.L55:
 1157              	.LBB122:
 172:rt_thread/src/ipc.c **** 
 1158              		.loc 1 172 9 view .LVU388
 172:rt_thread/src/ipc.c **** 
 1159              		.loc 1 172 16 is_stmt 0 view .LVU389
 1160 0030 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1161              	.LVL129:
 1162 0034 0446     		mov	r4, r0
 1163              	.LVL130:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1164              		.loc 1 175 9 is_stmt 1 view .LVU390
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1165              		.loc 1 175 18 is_stmt 0 view .LVU391
 1166 0036 2868     		ldr	r0, [r5]
 1167              	.LVL131:
 177:rt_thread/src/ipc.c **** 
 1168              		.loc 1 177 9 is_stmt 1 view .LVU392
 177:rt_thread/src/ipc.c **** 
 1169              		.loc 1 177 23 is_stmt 0 view .LVU393
 1170 0038 4FF0FF33 		mov	r3, #-1
 1171 003c C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 1172              		.loc 1 184 9 is_stmt 1 view .LVU394
 1173 003e 1438     		subs	r0, r0, #20
 1174              	.LVL132:
 184:rt_thread/src/ipc.c **** 
 1175              		.loc 1 184 9 is_stmt 0 view .LVU395
 1176 0040 FFF7FEFF 		bl	rt_thread_resume
 1177              	.LVL133:
 187:rt_thread/src/ipc.c ****     }
 1178              		.loc 1 187 9 is_stmt 1 view .LVU396
 1179 0044 2046     		mov	r0, r4
 1180 0046 FFF7FEFF 		bl	rt_hw_interrupt_enable
ARM GAS  /tmp/ccDOLSjn.s 			page 51


 1181              	.LVL134:
 1182              	.L54:
 169:rt_thread/src/ipc.c ****     {
 1183              		.loc 1 169 11 view .LVU397
 1184              	.LBB123:
 1185              	.LBI123:
  98:rt_thread/include/rtservice.h **** {
 1186              		.loc 2 98 15 view .LVU398
 1187              	.LBB124:
 1188              		.loc 2 100 5 view .LVU399
 1189              		.loc 2 100 13 is_stmt 0 view .LVU400
 1190 004a 2B68     		ldr	r3, [r5]
 1191              	.LVL135:
 1192              		.loc 2 100 13 view .LVU401
 1193              	.LBE124:
 1194              	.LBE123:
 169:rt_thread/src/ipc.c ****     {
 1195              		.loc 1 169 11 view .LVU402
 1196 004c 9D42     		cmp	r5, r3
 1197 004e EFD1     		bne	.L55
 190:rt_thread/src/ipc.c **** }
 1198              		.loc 1 190 5 is_stmt 1 view .LVU403
 1199              	.LVL136:
 190:rt_thread/src/ipc.c **** }
 1200              		.loc 1 190 5 is_stmt 0 view .LVU404
 1201              	.LBE122:
 1202              	.LBE121:
1380:rt_thread/src/ipc.c **** 
1381:rt_thread/src/ipc.c ****     /* detach mailbox object */
1382:rt_thread/src/ipc.c ****     rt_object_detach(&(mb->parent.parent));
 1203              		.loc 1 1382 5 is_stmt 1 view .LVU405
 1204 0050 3046     		mov	r0, r6
 1205 0052 FFF7FEFF 		bl	rt_object_detach
 1206              	.LVL137:
1383:rt_thread/src/ipc.c **** 
1384:rt_thread/src/ipc.c ****     return RT_EOK;
 1207              		.loc 1 1384 5 view .LVU406
1385:rt_thread/src/ipc.c **** }
 1208              		.loc 1 1385 1 is_stmt 0 view .LVU407
 1209 0056 0020     		movs	r0, #0
 1210 0058 70BD     		pop	{r4, r5, r6, pc}
 1211              		.loc 1 1385 1 view .LVU408
 1212              		.cfi_endproc
 1213              	.LFE28:
 1215              		.section	.text.rt_mb_create,"ax",%progbits
 1216              		.align	1
 1217              		.global	rt_mb_create
 1218              		.syntax unified
 1219              		.thumb
 1220              		.thumb_func
 1222              	rt_mb_create:
 1223              	.LVL138:
 1224              	.LFB29:
1386:rt_thread/src/ipc.c **** 
1387:rt_thread/src/ipc.c **** #ifdef RT_USING_HEAP
1388:rt_thread/src/ipc.c **** /**
1389:rt_thread/src/ipc.c ****  * This function will create a mailbox object from system resource
ARM GAS  /tmp/ccDOLSjn.s 			page 52


1390:rt_thread/src/ipc.c ****  *
1391:rt_thread/src/ipc.c ****  * @param name the name of mailbox
1392:rt_thread/src/ipc.c ****  * @param size the size of mailbox
1393:rt_thread/src/ipc.c ****  * @param flag the flag of mailbox
1394:rt_thread/src/ipc.c ****  *
1395:rt_thread/src/ipc.c ****  * @return the created mailbox, RT_NULL on error happen
1396:rt_thread/src/ipc.c ****  */
1397:rt_thread/src/ipc.c **** rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
1398:rt_thread/src/ipc.c **** {
 1225              		.loc 1 1398 1 is_stmt 1 view -0
 1226              		.cfi_startproc
 1227              		@ args = 0, pretend = 0, frame = 0
 1228              		@ frame_needed = 0, uses_anonymous_args = 0
 1229              		.loc 1 1398 1 is_stmt 0 view .LVU410
 1230 0000 70B5     		push	{r4, r5, r6, lr}
 1231              	.LCFI14:
 1232              		.cfi_def_cfa_offset 16
 1233              		.cfi_offset 4, -16
 1234              		.cfi_offset 5, -12
 1235              		.cfi_offset 6, -8
 1236              		.cfi_offset 14, -4
 1237 0002 0D46     		mov	r5, r1
 1238 0004 1646     		mov	r6, r2
1399:rt_thread/src/ipc.c ****     rt_mailbox_t mb;
 1239              		.loc 1 1399 5 is_stmt 1 view .LVU411
1400:rt_thread/src/ipc.c **** 
1401:rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 1240              		.loc 1 1401 30 view .LVU412
1402:rt_thread/src/ipc.c **** 
1403:rt_thread/src/ipc.c ****     /* allocate object */
1404:rt_thread/src/ipc.c ****     mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
 1241              		.loc 1 1404 5 view .LVU413
 1242              		.loc 1 1404 24 is_stmt 0 view .LVU414
 1243 0006 0146     		mov	r1, r0
 1244              	.LVL139:
 1245              		.loc 1 1404 24 view .LVU415
 1246 0008 0520     		movs	r0, #5
 1247              	.LVL140:
 1248              		.loc 1 1404 24 view .LVU416
 1249 000a FFF7FEFF 		bl	rt_object_allocate
 1250              	.LVL141:
1405:rt_thread/src/ipc.c ****     if (mb == RT_NULL)
 1251              		.loc 1 1405 5 is_stmt 1 view .LVU417
 1252              		.loc 1 1405 8 is_stmt 0 view .LVU418
 1253 000e 0446     		mov	r4, r0
 1254 0010 A0B1     		cbz	r0, .L57
1406:rt_thread/src/ipc.c ****         return mb;
1407:rt_thread/src/ipc.c **** 
1408:rt_thread/src/ipc.c ****     /* set parent */
1409:rt_thread/src/ipc.c ****     mb->parent.parent.flag = flag;
 1255              		.loc 1 1409 5 is_stmt 1 view .LVU419
 1256              		.loc 1 1409 28 is_stmt 0 view .LVU420
 1257 0012 4672     		strb	r6, [r0, #9]
1410:rt_thread/src/ipc.c **** 
1411:rt_thread/src/ipc.c ****     /* initialize ipc object */
1412:rt_thread/src/ipc.c ****     rt_ipc_object_init(&(mb->parent));
 1258              		.loc 1 1412 5 is_stmt 1 view .LVU421
ARM GAS  /tmp/ccDOLSjn.s 			page 53


 1259              	.LVL142:
 1260              	.LBB125:
 1261              	.LBI125:
  64:rt_thread/src/ipc.c **** {
 1262              		.loc 1 64 20 view .LVU422
 1263              	.LBB126:
  67:rt_thread/src/ipc.c **** 
 1264              		.loc 1 67 5 view .LVU423
 1265 0014 00F11403 		add	r3, r0, #20
 1266              	.LVL143:
 1267              	.LBB127:
 1268              	.LBI127:
  47:rt_thread/include/rtservice.h **** {
 1269              		.loc 2 47 16 view .LVU424
 1270              	.LBB128:
  49:rt_thread/include/rtservice.h **** }
 1271              		.loc 2 49 5 view .LVU425
  49:rt_thread/include/rtservice.h **** }
 1272              		.loc 2 49 23 is_stmt 0 view .LVU426
 1273 0018 8361     		str	r3, [r0, #24]
  49:rt_thread/include/rtservice.h **** }
 1274              		.loc 2 49 13 view .LVU427
 1275 001a 4361     		str	r3, [r0, #20]
 1276              	.LVL144:
  49:rt_thread/include/rtservice.h **** }
 1277              		.loc 2 49 13 view .LVU428
 1278              	.LBE128:
 1279              	.LBE127:
  69:rt_thread/src/ipc.c **** }
 1280              		.loc 1 69 5 is_stmt 1 view .LVU429
  69:rt_thread/src/ipc.c **** }
 1281              		.loc 1 69 5 is_stmt 0 view .LVU430
 1282              	.LBE126:
 1283              	.LBE125:
1413:rt_thread/src/ipc.c **** 
1414:rt_thread/src/ipc.c ****     /* initialize mailbox */
1415:rt_thread/src/ipc.c ****     mb->size     = size;
 1284              		.loc 1 1415 5 is_stmt 1 view .LVU431
 1285              		.loc 1 1415 18 is_stmt 0 view .LVU432
 1286 001c A8B2     		uxth	r0, r5
 1287              	.LVL145:
 1288              		.loc 1 1415 18 view .LVU433
 1289 001e 2084     		strh	r0, [r4, #32]	@ movhi
1416:rt_thread/src/ipc.c ****     mb->msg_pool = (rt_ubase_t *)RT_KERNEL_MALLOC(mb->size * sizeof(rt_ubase_t));
 1290              		.loc 1 1416 5 is_stmt 1 view .LVU434
 1291              		.loc 1 1416 34 is_stmt 0 view .LVU435
 1292 0020 8000     		lsls	r0, r0, #2
 1293 0022 FFF7FEFF 		bl	rt_malloc
 1294              	.LVL146:
 1295 0026 0546     		mov	r5, r0
 1296              	.LVL147:
 1297              		.loc 1 1416 18 view .LVU436
 1298 0028 E061     		str	r0, [r4, #28]
1417:rt_thread/src/ipc.c ****     if (mb->msg_pool == RT_NULL)
 1299              		.loc 1 1417 5 is_stmt 1 view .LVU437
 1300              		.loc 1 1417 8 is_stmt 0 view .LVU438
 1301 002a 48B1     		cbz	r0, .L61
ARM GAS  /tmp/ccDOLSjn.s 			page 54


1418:rt_thread/src/ipc.c ****     {
1419:rt_thread/src/ipc.c ****         /* delete mailbox object */
1420:rt_thread/src/ipc.c ****         rt_object_delete(&(mb->parent.parent));
1421:rt_thread/src/ipc.c **** 
1422:rt_thread/src/ipc.c ****         return RT_NULL;
1423:rt_thread/src/ipc.c ****     }
1424:rt_thread/src/ipc.c ****     mb->entry      = 0;
 1302              		.loc 1 1424 5 is_stmt 1 view .LVU439
 1303              		.loc 1 1424 20 is_stmt 0 view .LVU440
 1304 002c 0023     		movs	r3, #0
 1305 002e 6384     		strh	r3, [r4, #34]	@ movhi
1425:rt_thread/src/ipc.c ****     mb->in_offset  = 0;
 1306              		.loc 1 1425 5 is_stmt 1 view .LVU441
 1307              		.loc 1 1425 20 is_stmt 0 view .LVU442
 1308 0030 A384     		strh	r3, [r4, #36]	@ movhi
1426:rt_thread/src/ipc.c ****     mb->out_offset = 0;
 1309              		.loc 1 1426 5 is_stmt 1 view .LVU443
 1310              		.loc 1 1426 20 is_stmt 0 view .LVU444
 1311 0032 E384     		strh	r3, [r4, #38]	@ movhi
1427:rt_thread/src/ipc.c **** 
1428:rt_thread/src/ipc.c ****     /* initialize an additional list of sender suspend thread */
1429:rt_thread/src/ipc.c ****     rt_list_init(&(mb->suspend_sender_thread));
 1312              		.loc 1 1429 5 is_stmt 1 view .LVU445
 1313 0034 04F12803 		add	r3, r4, #40
 1314              	.LVL148:
 1315              	.LBB129:
 1316              	.LBI129:
  47:rt_thread/include/rtservice.h **** {
 1317              		.loc 2 47 16 view .LVU446
 1318              	.LBB130:
  49:rt_thread/include/rtservice.h **** }
 1319              		.loc 2 49 5 view .LVU447
  49:rt_thread/include/rtservice.h **** }
 1320              		.loc 2 49 23 is_stmt 0 view .LVU448
 1321 0038 E362     		str	r3, [r4, #44]
  49:rt_thread/include/rtservice.h **** }
 1322              		.loc 2 49 13 view .LVU449
 1323 003a A362     		str	r3, [r4, #40]
 1324              	.LVL149:
  49:rt_thread/include/rtservice.h **** }
 1325              		.loc 2 49 13 view .LVU450
 1326              	.LBE130:
 1327              	.LBE129:
1430:rt_thread/src/ipc.c **** 
1431:rt_thread/src/ipc.c ****     return mb;
 1328              		.loc 1 1431 5 is_stmt 1 view .LVU451
 1329              	.L57:
1432:rt_thread/src/ipc.c **** }
 1330              		.loc 1 1432 1 is_stmt 0 view .LVU452
 1331 003c 2046     		mov	r0, r4
 1332 003e 70BD     		pop	{r4, r5, r6, pc}
 1333              	.LVL150:
 1334              	.L61:
1420:rt_thread/src/ipc.c **** 
 1335              		.loc 1 1420 9 is_stmt 1 view .LVU453
 1336 0040 2046     		mov	r0, r4
 1337 0042 FFF7FEFF 		bl	rt_object_delete
ARM GAS  /tmp/ccDOLSjn.s 			page 55


 1338              	.LVL151:
1422:rt_thread/src/ipc.c ****     }
 1339              		.loc 1 1422 9 view .LVU454
1422:rt_thread/src/ipc.c ****     }
 1340              		.loc 1 1422 16 is_stmt 0 view .LVU455
 1341 0046 2C46     		mov	r4, r5
 1342              	.LVL152:
1422:rt_thread/src/ipc.c ****     }
 1343              		.loc 1 1422 16 view .LVU456
 1344 0048 F8E7     		b	.L57
 1345              		.cfi_endproc
 1346              	.LFE29:
 1348              		.section	.text.rt_mb_delete,"ax",%progbits
 1349              		.align	1
 1350              		.global	rt_mb_delete
 1351              		.syntax unified
 1352              		.thumb
 1353              		.thumb_func
 1355              	rt_mb_delete:
 1356              	.LVL153:
 1357              	.LFB30:
1433:rt_thread/src/ipc.c **** 
1434:rt_thread/src/ipc.c **** /**
1435:rt_thread/src/ipc.c ****  * This function will delete a mailbox object and release the memory
1436:rt_thread/src/ipc.c ****  *
1437:rt_thread/src/ipc.c ****  * @param mb the mailbox object
1438:rt_thread/src/ipc.c ****  *
1439:rt_thread/src/ipc.c ****  * @return the error code
1440:rt_thread/src/ipc.c ****  */
1441:rt_thread/src/ipc.c **** rt_err_t rt_mb_delete(rt_mailbox_t mb)
1442:rt_thread/src/ipc.c **** {
 1358              		.loc 1 1442 1 is_stmt 1 view -0
 1359              		.cfi_startproc
 1360              		@ args = 0, pretend = 0, frame = 0
 1361              		@ frame_needed = 0, uses_anonymous_args = 0
 1362              		.loc 1 1442 1 is_stmt 0 view .LVU458
 1363 0000 70B5     		push	{r4, r5, r6, lr}
 1364              	.LCFI15:
 1365              		.cfi_def_cfa_offset 16
 1366              		.cfi_offset 4, -16
 1367              		.cfi_offset 5, -12
 1368              		.cfi_offset 6, -8
 1369              		.cfi_offset 14, -4
 1370 0002 0646     		mov	r6, r0
1443:rt_thread/src/ipc.c ****     RT_DEBUG_NOT_IN_INTERRUPT;
 1371              		.loc 1 1443 30 is_stmt 1 view .LVU459
1444:rt_thread/src/ipc.c **** 
1445:rt_thread/src/ipc.c ****     /* parameter check */
1446:rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
 1372              		.loc 1 1446 29 view .LVU460
1447:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
 1373              		.loc 1 1447 81 view .LVU461
1448:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_is_systemobject(&mb->parent.parent) == RT_FALSE);
 1374              		.loc 1 1448 73 view .LVU462
1449:rt_thread/src/ipc.c **** 
1450:rt_thread/src/ipc.c ****     /* resume all suspended thread */
1451:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
ARM GAS  /tmp/ccDOLSjn.s 			page 56


 1375              		.loc 1 1451 5 view .LVU463
 1376 0004 00F11405 		add	r5, r0, #20
 1377              	.LVL154:
 1378              	.LBB139:
 1379              	.LBI139:
 163:rt_thread/src/ipc.c **** {
 1380              		.loc 1 163 20 view .LVU464
 1381              	.LBB140:
 165:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 1382              		.loc 1 165 5 view .LVU465
 166:rt_thread/src/ipc.c **** 
 1383              		.loc 1 166 5 view .LVU466
 169:rt_thread/src/ipc.c ****     {
 1384              		.loc 1 169 5 view .LVU467
 169:rt_thread/src/ipc.c ****     {
 1385              		.loc 1 169 11 is_stmt 0 view .LVU468
 1386 0008 0CE0     		b	.L63
 1387              	.LVL155:
 1388              	.L64:
 172:rt_thread/src/ipc.c **** 
 1389              		.loc 1 172 9 is_stmt 1 view .LVU469
 172:rt_thread/src/ipc.c **** 
 1390              		.loc 1 172 16 is_stmt 0 view .LVU470
 1391 000a FFF7FEFF 		bl	rt_hw_interrupt_disable
 1392              	.LVL156:
 1393 000e 0446     		mov	r4, r0
 1394              	.LVL157:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1395              		.loc 1 175 9 is_stmt 1 view .LVU471
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1396              		.loc 1 175 18 is_stmt 0 view .LVU472
 1397 0010 2868     		ldr	r0, [r5]
 1398              	.LVL158:
 177:rt_thread/src/ipc.c **** 
 1399              		.loc 1 177 9 is_stmt 1 view .LVU473
 177:rt_thread/src/ipc.c **** 
 1400              		.loc 1 177 23 is_stmt 0 view .LVU474
 1401 0012 4FF0FF33 		mov	r3, #-1
 1402 0016 C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 1403              		.loc 1 184 9 is_stmt 1 view .LVU475
 1404 0018 1438     		subs	r0, r0, #20
 1405              	.LVL159:
 184:rt_thread/src/ipc.c **** 
 1406              		.loc 1 184 9 is_stmt 0 view .LVU476
 1407 001a FFF7FEFF 		bl	rt_thread_resume
 1408              	.LVL160:
 187:rt_thread/src/ipc.c ****     }
 1409              		.loc 1 187 9 is_stmt 1 view .LVU477
 1410 001e 2046     		mov	r0, r4
 1411 0020 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1412              	.LVL161:
 1413              	.L63:
 169:rt_thread/src/ipc.c ****     {
 1414              		.loc 1 169 11 view .LVU478
 1415              	.LBB141:
 1416              	.LBI141:
ARM GAS  /tmp/ccDOLSjn.s 			page 57


  98:rt_thread/include/rtservice.h **** {
 1417              		.loc 2 98 15 view .LVU479
 1418              	.LBB142:
 1419              		.loc 2 100 5 view .LVU480
 1420              		.loc 2 100 13 is_stmt 0 view .LVU481
 1421 0024 2B68     		ldr	r3, [r5]
 1422              	.LVL162:
 1423              		.loc 2 100 13 view .LVU482
 1424              	.LBE142:
 1425              	.LBE141:
 169:rt_thread/src/ipc.c ****     {
 1426              		.loc 1 169 11 view .LVU483
 1427 0026 9D42     		cmp	r5, r3
 1428 0028 EFD1     		bne	.L64
 190:rt_thread/src/ipc.c **** }
 1429              		.loc 1 190 5 is_stmt 1 view .LVU484
 1430              	.LVL163:
 190:rt_thread/src/ipc.c **** }
 1431              		.loc 1 190 5 is_stmt 0 view .LVU485
 1432              	.LBE140:
 1433              	.LBE139:
1452:rt_thread/src/ipc.c **** 
1453:rt_thread/src/ipc.c ****     /* also resume all mailbox private suspended thread */
1454:rt_thread/src/ipc.c ****     rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
 1434              		.loc 1 1454 5 is_stmt 1 view .LVU486
 1435 002a 06F12805 		add	r5, r6, #40
 1436              	.LVL164:
 1437              	.LBB143:
 1438              	.LBI143:
 163:rt_thread/src/ipc.c **** {
 1439              		.loc 1 163 20 view .LVU487
 1440 002e 0CE0     		b	.L65
 1441              	.L66:
 1442              	.LBB144:
 172:rt_thread/src/ipc.c **** 
 1443              		.loc 1 172 9 view .LVU488
 172:rt_thread/src/ipc.c **** 
 1444              		.loc 1 172 16 is_stmt 0 view .LVU489
 1445 0030 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1446              	.LVL165:
 1447 0034 0446     		mov	r4, r0
 1448              	.LVL166:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1449              		.loc 1 175 9 is_stmt 1 view .LVU490
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 1450              		.loc 1 175 18 is_stmt 0 view .LVU491
 1451 0036 2868     		ldr	r0, [r5]
 1452              	.LVL167:
 177:rt_thread/src/ipc.c **** 
 1453              		.loc 1 177 9 is_stmt 1 view .LVU492
 177:rt_thread/src/ipc.c **** 
 1454              		.loc 1 177 23 is_stmt 0 view .LVU493
 1455 0038 4FF0FF33 		mov	r3, #-1
 1456 003c C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 1457              		.loc 1 184 9 is_stmt 1 view .LVU494
 1458 003e 1438     		subs	r0, r0, #20
ARM GAS  /tmp/ccDOLSjn.s 			page 58


 1459              	.LVL168:
 184:rt_thread/src/ipc.c **** 
 1460              		.loc 1 184 9 is_stmt 0 view .LVU495
 1461 0040 FFF7FEFF 		bl	rt_thread_resume
 1462              	.LVL169:
 187:rt_thread/src/ipc.c ****     }
 1463              		.loc 1 187 9 is_stmt 1 view .LVU496
 1464 0044 2046     		mov	r0, r4
 1465 0046 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1466              	.LVL170:
 1467              	.L65:
 169:rt_thread/src/ipc.c ****     {
 1468              		.loc 1 169 11 view .LVU497
 1469              	.LBB145:
 1470              	.LBI145:
  98:rt_thread/include/rtservice.h **** {
 1471              		.loc 2 98 15 view .LVU498
 1472              	.LBB146:
 1473              		.loc 2 100 5 view .LVU499
 1474              		.loc 2 100 13 is_stmt 0 view .LVU500
 1475 004a 2B68     		ldr	r3, [r5]
 1476              	.LVL171:
 1477              		.loc 2 100 13 view .LVU501
 1478              	.LBE146:
 1479              	.LBE145:
 169:rt_thread/src/ipc.c ****     {
 1480              		.loc 1 169 11 view .LVU502
 1481 004c 9D42     		cmp	r5, r3
 1482 004e EFD1     		bne	.L66
 190:rt_thread/src/ipc.c **** }
 1483              		.loc 1 190 5 is_stmt 1 view .LVU503
 1484              	.LVL172:
 190:rt_thread/src/ipc.c **** }
 1485              		.loc 1 190 5 is_stmt 0 view .LVU504
 1486              	.LBE144:
 1487              	.LBE143:
1455:rt_thread/src/ipc.c **** 
1456:rt_thread/src/ipc.c ****     /* free mailbox pool */
1457:rt_thread/src/ipc.c ****     RT_KERNEL_FREE(mb->msg_pool);
 1488              		.loc 1 1457 5 is_stmt 1 view .LVU505
 1489 0050 F069     		ldr	r0, [r6, #28]
 1490 0052 FFF7FEFF 		bl	rt_free
 1491              	.LVL173:
1458:rt_thread/src/ipc.c **** 
1459:rt_thread/src/ipc.c ****     /* delete mailbox object */
1460:rt_thread/src/ipc.c ****     rt_object_delete(&(mb->parent.parent));
 1492              		.loc 1 1460 5 view .LVU506
 1493 0056 3046     		mov	r0, r6
 1494 0058 FFF7FEFF 		bl	rt_object_delete
 1495              	.LVL174:
1461:rt_thread/src/ipc.c **** 
1462:rt_thread/src/ipc.c ****     return RT_EOK;
 1496              		.loc 1 1462 5 view .LVU507
1463:rt_thread/src/ipc.c **** }
 1497              		.loc 1 1463 1 is_stmt 0 view .LVU508
 1498 005c 0020     		movs	r0, #0
 1499 005e 70BD     		pop	{r4, r5, r6, pc}
ARM GAS  /tmp/ccDOLSjn.s 			page 59


 1500              		.loc 1 1463 1 view .LVU509
 1501              		.cfi_endproc
 1502              	.LFE30:
 1504              		.section	.text.rt_mb_send_wait,"ax",%progbits
 1505              		.align	1
 1506              		.global	rt_mb_send_wait
 1507              		.syntax unified
 1508              		.thumb
 1509              		.thumb_func
 1511              	rt_mb_send_wait:
 1512              	.LVL175:
 1513              	.LFB31:
1464:rt_thread/src/ipc.c **** #endif
1465:rt_thread/src/ipc.c **** 
1466:rt_thread/src/ipc.c **** /**
1467:rt_thread/src/ipc.c ****  * This function will send a mail to mailbox object. If the mailbox is full,
1468:rt_thread/src/ipc.c ****  * current thread will be suspended until timeout.
1469:rt_thread/src/ipc.c ****  *
1470:rt_thread/src/ipc.c ****  * @param mb the mailbox object
1471:rt_thread/src/ipc.c ****  * @param value the mail
1472:rt_thread/src/ipc.c ****  * @param timeout the waiting time
1473:rt_thread/src/ipc.c ****  *
1474:rt_thread/src/ipc.c ****  * @return the error code
1475:rt_thread/src/ipc.c ****  */
1476:rt_thread/src/ipc.c **** rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
1477:rt_thread/src/ipc.c ****                          rt_ubase_t   value,
1478:rt_thread/src/ipc.c ****                          rt_int32_t   timeout)
1479:rt_thread/src/ipc.c **** {
 1514              		.loc 1 1479 1 is_stmt 1 view -0
 1515              		.cfi_startproc
 1516              		@ args = 0, pretend = 0, frame = 8
 1517              		@ frame_needed = 0, uses_anonymous_args = 0
 1518              		.loc 1 1479 1 is_stmt 0 view .LVU511
 1519 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 1520              	.LCFI16:
 1521              		.cfi_def_cfa_offset 32
 1522              		.cfi_offset 4, -32
 1523              		.cfi_offset 5, -28
 1524              		.cfi_offset 6, -24
 1525              		.cfi_offset 7, -20
 1526              		.cfi_offset 8, -16
 1527              		.cfi_offset 9, -12
 1528              		.cfi_offset 10, -8
 1529              		.cfi_offset 14, -4
 1530 0004 82B0     		sub	sp, sp, #8
 1531              	.LCFI17:
 1532              		.cfi_def_cfa_offset 40
 1533 0006 0646     		mov	r6, r0
 1534 0008 8946     		mov	r9, r1
 1535 000a 0192     		str	r2, [sp, #4]
1480:rt_thread/src/ipc.c ****     struct rt_thread *thread;
 1536              		.loc 1 1480 5 is_stmt 1 view .LVU512
1481:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 1537              		.loc 1 1481 5 view .LVU513
1482:rt_thread/src/ipc.c ****     rt_uint32_t tick_delta;
 1538              		.loc 1 1482 5 view .LVU514
1483:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 60


1484:rt_thread/src/ipc.c ****     /* parameter check */
1485:rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
 1539              		.loc 1 1485 29 view .LVU515
1486:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
 1540              		.loc 1 1486 81 view .LVU516
1487:rt_thread/src/ipc.c **** 
1488:rt_thread/src/ipc.c ****     /* initialize delta tick */
1489:rt_thread/src/ipc.c ****     tick_delta = 0;
 1541              		.loc 1 1489 5 view .LVU517
 1542              	.LVL176:
1490:rt_thread/src/ipc.c ****     /* get current thread */
1491:rt_thread/src/ipc.c ****     thread = rt_thread_self();
 1543              		.loc 1 1491 5 view .LVU518
 1544              		.loc 1 1491 14 is_stmt 0 view .LVU519
 1545 000c FFF7FEFF 		bl	rt_thread_self
 1546              	.LVL177:
 1547              		.loc 1 1491 14 view .LVU520
 1548 0010 0446     		mov	r4, r0
 1549              	.LVL178:
1492:rt_thread/src/ipc.c **** 
1493:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
 1550              		.loc 1 1493 68 is_stmt 1 view .LVU521
1494:rt_thread/src/ipc.c **** 
1495:rt_thread/src/ipc.c ****     /* disable interrupt */
1496:rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 1551              		.loc 1 1496 5 view .LVU522
 1552              		.loc 1 1496 12 is_stmt 0 view .LVU523
 1553 0012 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1554              	.LVL179:
 1555              		.loc 1 1496 10 view .LVU524
 1556 0016 0746     		mov	r7, r0
 1557              	.LVL180:
1497:rt_thread/src/ipc.c **** 
1498:rt_thread/src/ipc.c ****     /* for non-blocking call */
1499:rt_thread/src/ipc.c ****     if (mb->entry == mb->size && timeout == 0)
 1558              		.loc 1 1499 5 is_stmt 1 view .LVU525
 1559              		.loc 1 1499 11 is_stmt 0 view .LVU526
 1560 0018 728C     		ldrh	r2, [r6, #34]
 1561              		.loc 1 1499 24 view .LVU527
 1562 001a 338C     		ldrh	r3, [r6, #32]
 1563              		.loc 1 1499 8 view .LVU528
 1564 001c 9A42     		cmp	r2, r3
 1565 001e 02D0     		beq	.L92
 1566 0020 4FF00008 		mov	r8, #0
 1567 0024 2AE0     		b	.L81
 1568              	.L92:
 1569              		.loc 1 1499 42 discriminator 1 view .LVU529
 1570 0026 019B     		ldr	r3, [sp, #4]
 1571              		.loc 1 1499 31 discriminator 1 view .LVU530
 1572 0028 13B1     		cbz	r3, .L93
 1573 002a 4FF00008 		mov	r8, #0
 1574 002e 25E0     		b	.L81
 1575              	.L93:
1500:rt_thread/src/ipc.c ****     {
1501:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 1576              		.loc 1 1501 9 is_stmt 1 view .LVU531
 1577 0030 FFF7FEFF 		bl	rt_hw_interrupt_enable
ARM GAS  /tmp/ccDOLSjn.s 			page 61


 1578              	.LVL181:
1502:rt_thread/src/ipc.c **** 
1503:rt_thread/src/ipc.c ****         return -RT_EFULL;
 1579              		.loc 1 1503 9 view .LVU532
 1580              		.loc 1 1503 16 is_stmt 0 view .LVU533
 1581 0034 6FF00200 		mvn	r0, #2
 1582 0038 04E0     		b	.L68
 1583              	.LVL182:
 1584              	.L97:
1504:rt_thread/src/ipc.c ****     }
1505:rt_thread/src/ipc.c **** 
1506:rt_thread/src/ipc.c ****     /* mailbox is full */
1507:rt_thread/src/ipc.c ****     while (mb->entry == mb->size)
1508:rt_thread/src/ipc.c ****     {
1509:rt_thread/src/ipc.c ****         /* reset error number in thread */
1510:rt_thread/src/ipc.c ****         thread->error = RT_EOK;
1511:rt_thread/src/ipc.c **** 
1512:rt_thread/src/ipc.c ****         /* no waiting, return timeout */
1513:rt_thread/src/ipc.c ****         if (timeout == 0)
1514:rt_thread/src/ipc.c ****         {
1515:rt_thread/src/ipc.c ****             /* enable interrupt */
1516:rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 1585              		.loc 1 1516 13 is_stmt 1 view .LVU534
 1586 003a 3846     		mov	r0, r7
 1587 003c FFF7FEFF 		bl	rt_hw_interrupt_enable
 1588              	.LVL183:
1517:rt_thread/src/ipc.c **** 
1518:rt_thread/src/ipc.c ****             return -RT_EFULL;
 1589              		.loc 1 1518 13 view .LVU535
 1590              		.loc 1 1518 20 is_stmt 0 view .LVU536
 1591 0040 6FF00200 		mvn	r0, #2
 1592              	.LVL184:
 1593              	.L68:
1519:rt_thread/src/ipc.c ****         }
1520:rt_thread/src/ipc.c **** 
1521:rt_thread/src/ipc.c ****         RT_DEBUG_IN_THREAD_CONTEXT;
1522:rt_thread/src/ipc.c ****         /* suspend current thread */
1523:rt_thread/src/ipc.c ****         rt_ipc_list_suspend(&(mb->suspend_sender_thread),
1524:rt_thread/src/ipc.c ****                             thread,
1525:rt_thread/src/ipc.c ****                             mb->parent.parent.flag);
1526:rt_thread/src/ipc.c **** 
1527:rt_thread/src/ipc.c ****         /* has waiting time, start thread timer */
1528:rt_thread/src/ipc.c ****         if (timeout > 0)
1529:rt_thread/src/ipc.c ****         {
1530:rt_thread/src/ipc.c ****             /* get the start tick of timer */
1531:rt_thread/src/ipc.c ****             tick_delta = rt_tick_get();
1532:rt_thread/src/ipc.c **** 
1533:rt_thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
1534:rt_thread/src/ipc.c ****                                         thread->name));
1535:rt_thread/src/ipc.c **** 
1536:rt_thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
1537:rt_thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
1538:rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1539:rt_thread/src/ipc.c ****                              &timeout);
1540:rt_thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
1541:rt_thread/src/ipc.c ****         }
1542:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 62


1543:rt_thread/src/ipc.c ****         /* enable interrupt */
1544:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1545:rt_thread/src/ipc.c **** 
1546:rt_thread/src/ipc.c ****         /* re-schedule */
1547:rt_thread/src/ipc.c ****         rt_schedule();
1548:rt_thread/src/ipc.c **** 
1549:rt_thread/src/ipc.c ****         /* resume from suspend state */
1550:rt_thread/src/ipc.c ****         if (thread->error != RT_EOK)
1551:rt_thread/src/ipc.c ****         {
1552:rt_thread/src/ipc.c ****             /* return error */
1553:rt_thread/src/ipc.c ****             return thread->error;
1554:rt_thread/src/ipc.c ****         }
1555:rt_thread/src/ipc.c **** 
1556:rt_thread/src/ipc.c ****         /* disable interrupt */
1557:rt_thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
1558:rt_thread/src/ipc.c **** 
1559:rt_thread/src/ipc.c ****         /* if it's not waiting forever and then re-calculate timeout tick */
1560:rt_thread/src/ipc.c ****         if (timeout > 0)
1561:rt_thread/src/ipc.c ****         {
1562:rt_thread/src/ipc.c ****             tick_delta = rt_tick_get() - tick_delta;
1563:rt_thread/src/ipc.c ****             timeout -= tick_delta;
1564:rt_thread/src/ipc.c ****             if (timeout < 0)
1565:rt_thread/src/ipc.c ****                 timeout = 0;
1566:rt_thread/src/ipc.c ****         }
1567:rt_thread/src/ipc.c ****     }
1568:rt_thread/src/ipc.c **** 
1569:rt_thread/src/ipc.c ****     /* set ptr */
1570:rt_thread/src/ipc.c ****     mb->msg_pool[mb->in_offset] = value;
1571:rt_thread/src/ipc.c ****     /* increase input offset */
1572:rt_thread/src/ipc.c ****     ++ mb->in_offset;
1573:rt_thread/src/ipc.c ****     if (mb->in_offset >= mb->size)
1574:rt_thread/src/ipc.c ****         mb->in_offset = 0;
1575:rt_thread/src/ipc.c **** 
1576:rt_thread/src/ipc.c ****     if(mb->entry < RT_MB_ENTRY_MAX)
1577:rt_thread/src/ipc.c ****     {
1578:rt_thread/src/ipc.c ****         /* increase message entry */
1579:rt_thread/src/ipc.c ****         mb->entry ++;
1580:rt_thread/src/ipc.c ****     }
1581:rt_thread/src/ipc.c ****     else
1582:rt_thread/src/ipc.c ****     {
1583:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp); /* enable interrupt */
1584:rt_thread/src/ipc.c ****         return -RT_EFULL; /* value overflowed */
1585:rt_thread/src/ipc.c ****     }
1586:rt_thread/src/ipc.c **** 
1587:rt_thread/src/ipc.c ****     /* resume suspended thread */
1588:rt_thread/src/ipc.c ****     if (!rt_list_isempty(&mb->parent.suspend_thread))
1589:rt_thread/src/ipc.c ****     {
1590:rt_thread/src/ipc.c ****         rt_ipc_list_resume(&(mb->parent.suspend_thread));
1591:rt_thread/src/ipc.c **** 
1592:rt_thread/src/ipc.c ****         /* enable interrupt */
1593:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1594:rt_thread/src/ipc.c **** 
1595:rt_thread/src/ipc.c ****         rt_schedule();
1596:rt_thread/src/ipc.c **** 
1597:rt_thread/src/ipc.c ****         return RT_EOK;
1598:rt_thread/src/ipc.c ****     }
1599:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 63


1600:rt_thread/src/ipc.c ****     /* enable interrupt */
1601:rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
1602:rt_thread/src/ipc.c **** 
1603:rt_thread/src/ipc.c ****     return RT_EOK;
1604:rt_thread/src/ipc.c **** }
 1594              		.loc 1 1604 1 view .LVU537
 1595 0044 02B0     		add	sp, sp, #8
 1596              	.LCFI18:
 1597              		.cfi_remember_state
 1598              		.cfi_def_cfa_offset 32
 1599              		@ sp needed
 1600 0046 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 1601              	.LVL185:
 1602              	.L72:
 1603              	.LCFI19:
 1604              		.cfi_restore_state
 1605              	.LBB160:
 1606              	.LBB161:
  93:rt_thread/src/ipc.c ****         break;
 1607              		.loc 1 93 9 is_stmt 1 view .LVU538
 1608 004a 04F11403 		add	r3, r4, #20
 1609              	.LVL186:
 1610              	.LBB162:
 1611              	.LBI162:
  73:rt_thread/include/rtservice.h **** {
 1612              		.loc 2 73 16 view .LVU539
 1613              	.LBB163:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1614              		.loc 2 75 5 view .LVU540
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1615              		.loc 2 75 6 is_stmt 0 view .LVU541
 1616 004e 6A68     		ldr	r2, [r5, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1617              		.loc 2 75 19 view .LVU542
 1618 0050 1360     		str	r3, [r2]
  76:rt_thread/include/rtservice.h **** 
 1619              		.loc 2 76 5 is_stmt 1 view .LVU543
  76:rt_thread/include/rtservice.h **** 
 1620              		.loc 2 76 16 is_stmt 0 view .LVU544
 1621 0052 6A68     		ldr	r2, [r5, #4]
  76:rt_thread/include/rtservice.h **** 
 1622              		.loc 2 76 13 view .LVU545
 1623 0054 A261     		str	r2, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 1624              		.loc 2 78 5 is_stmt 1 view .LVU546
  78:rt_thread/include/rtservice.h ****     n->next = l;
 1625              		.loc 2 78 13 is_stmt 0 view .LVU547
 1626 0056 6B60     		str	r3, [r5, #4]
  79:rt_thread/include/rtservice.h **** }
 1627              		.loc 2 79 5 is_stmt 1 view .LVU548
  79:rt_thread/include/rtservice.h **** }
 1628              		.loc 2 79 13 is_stmt 0 view .LVU549
 1629 0058 6561     		str	r5, [r4, #20]
 1630              	.LVL187:
 1631              	.L74:
  79:rt_thread/include/rtservice.h **** }
 1632              		.loc 2 79 13 view .LVU550
ARM GAS  /tmp/ccDOLSjn.s 			page 64


 1633              	.LBE163:
 1634              	.LBE162:
 128:rt_thread/src/ipc.c **** }
 1635              		.loc 1 128 5 is_stmt 1 view .LVU551
 128:rt_thread/src/ipc.c **** }
 1636              		.loc 1 128 5 is_stmt 0 view .LVU552
 1637              	.LBE161:
 1638              	.LBE160:
1528:rt_thread/src/ipc.c ****         {
 1639              		.loc 1 1528 9 is_stmt 1 view .LVU553
1528:rt_thread/src/ipc.c ****         {
 1640              		.loc 1 1528 21 is_stmt 0 view .LVU554
 1641 005a 019B     		ldr	r3, [sp, #4]
1528:rt_thread/src/ipc.c ****         {
 1642              		.loc 1 1528 12 view .LVU555
 1643 005c 002B     		cmp	r3, #0
 1644 005e 41DC     		bgt	.L94
 1645              	.L79:
1544:rt_thread/src/ipc.c **** 
 1646              		.loc 1 1544 9 is_stmt 1 view .LVU556
 1647 0060 3846     		mov	r0, r7
 1648 0062 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1649              	.LVL188:
1547:rt_thread/src/ipc.c **** 
 1650              		.loc 1 1547 9 view .LVU557
 1651 0066 FFF7FEFF 		bl	rt_schedule
 1652              	.LVL189:
1550:rt_thread/src/ipc.c ****         {
 1653              		.loc 1 1550 9 view .LVU558
1550:rt_thread/src/ipc.c ****         {
 1654              		.loc 1 1550 19 is_stmt 0 view .LVU559
 1655 006a 206B     		ldr	r0, [r4, #48]
1550:rt_thread/src/ipc.c ****         {
 1656              		.loc 1 1550 12 view .LVU560
 1657 006c 0028     		cmp	r0, #0
 1658 006e E9D1     		bne	.L68
1557:rt_thread/src/ipc.c **** 
 1659              		.loc 1 1557 9 is_stmt 1 view .LVU561
1557:rt_thread/src/ipc.c **** 
 1660              		.loc 1 1557 16 is_stmt 0 view .LVU562
 1661 0070 FFF7FEFF 		bl	rt_hw_interrupt_disable
 1662              	.LVL190:
 1663 0074 0746     		mov	r7, r0
 1664              	.LVL191:
1560:rt_thread/src/ipc.c ****         {
 1665              		.loc 1 1560 9 is_stmt 1 view .LVU563
1560:rt_thread/src/ipc.c ****         {
 1666              		.loc 1 1560 21 is_stmt 0 view .LVU564
 1667 0076 019B     		ldr	r3, [sp, #4]
1560:rt_thread/src/ipc.c ****         {
 1668              		.loc 1 1560 12 view .LVU565
 1669 0078 002B     		cmp	r3, #0
 1670 007a 41DC     		bgt	.L95
 1671              	.LVL192:
 1672              	.L81:
1507:rt_thread/src/ipc.c ****     {
 1673              		.loc 1 1507 11 is_stmt 1 view .LVU566
ARM GAS  /tmp/ccDOLSjn.s 			page 65


1507:rt_thread/src/ipc.c ****     {
 1674              		.loc 1 1507 14 is_stmt 0 view .LVU567
 1675 007c 728C     		ldrh	r2, [r6, #34]
1507:rt_thread/src/ipc.c ****     {
 1676              		.loc 1 1507 27 view .LVU568
 1677 007e 338C     		ldrh	r3, [r6, #32]
1507:rt_thread/src/ipc.c ****     {
 1678              		.loc 1 1507 11 view .LVU569
 1679 0080 9A42     		cmp	r2, r3
 1680 0082 4ED1     		bne	.L96
1510:rt_thread/src/ipc.c **** 
 1681              		.loc 1 1510 9 is_stmt 1 view .LVU570
1510:rt_thread/src/ipc.c **** 
 1682              		.loc 1 1510 23 is_stmt 0 view .LVU571
 1683 0084 0023     		movs	r3, #0
 1684 0086 2363     		str	r3, [r4, #48]
1513:rt_thread/src/ipc.c ****         {
 1685              		.loc 1 1513 9 is_stmt 1 view .LVU572
1513:rt_thread/src/ipc.c ****         {
 1686              		.loc 1 1513 21 is_stmt 0 view .LVU573
 1687 0088 019B     		ldr	r3, [sp, #4]
1513:rt_thread/src/ipc.c ****         {
 1688              		.loc 1 1513 12 view .LVU574
 1689 008a 002B     		cmp	r3, #0
 1690 008c D5D0     		beq	.L97
1521:rt_thread/src/ipc.c ****         /* suspend current thread */
 1691              		.loc 1 1521 35 is_stmt 1 view .LVU575
1523:rt_thread/src/ipc.c ****                             thread,
 1692              		.loc 1 1523 9 view .LVU576
 1693 008e 06F12805 		add	r5, r6, #40
 1694 0092 96F809A0 		ldrb	r10, [r6, #9]	@ zero_extendqisi2
 1695              	.LVL193:
 1696              	.LBB170:
 1697              	.LBI160:
  83:rt_thread/src/ipc.c ****                                        struct rt_thread *thread,
 1698              		.loc 1 83 20 view .LVU577
 1699              	.LBB169:
  88:rt_thread/src/ipc.c **** 
 1700              		.loc 1 88 5 view .LVU578
 1701 0096 2046     		mov	r0, r4
 1702 0098 FFF7FEFF 		bl	rt_thread_suspend
 1703              	.LVL194:
  90:rt_thread/src/ipc.c ****     {
 1704              		.loc 1 90 5 view .LVU579
 1705 009c BAF1000F 		cmp	r10, #0
 1706 00a0 D3D0     		beq	.L72
 1707 00a2 BAF1010F 		cmp	r10, #1
 1708 00a6 D8D1     		bne	.L74
 1709              	.LBB164:
  98:rt_thread/src/ipc.c ****             struct rt_thread *sthread;
 1710              		.loc 1 98 13 view .LVU580
  99:rt_thread/src/ipc.c **** 
 1711              		.loc 1 99 13 view .LVU581
 102:rt_thread/src/ipc.c ****             {
 1712              		.loc 1 102 13 view .LVU582
 102:rt_thread/src/ipc.c ****             {
 1713              		.loc 1 102 20 is_stmt 0 view .LVU583
ARM GAS  /tmp/ccDOLSjn.s 			page 66


 1714 00a8 B36A     		ldr	r3, [r6, #40]
 1715              	.LVL195:
 1716              	.L75:
 102:rt_thread/src/ipc.c ****             {
 1717              		.loc 1 102 34 is_stmt 1 view .LVU584
 102:rt_thread/src/ipc.c ****             {
 1718              		.loc 1 102 13 is_stmt 0 view .LVU585
 1719 00aa 9D42     		cmp	r5, r3
 1720 00ac 0FD0     		beq	.L77
 104:rt_thread/src/ipc.c **** 
 1721              		.loc 1 104 17 is_stmt 1 view .LVU586
 1722              	.LVL196:
 107:rt_thread/src/ipc.c ****                 {
 1723              		.loc 1 107 17 view .LVU587
 107:rt_thread/src/ipc.c ****                 {
 1724              		.loc 1 107 27 is_stmt 0 view .LVU588
 1725 00ae 94F83510 		ldrb	r1, [r4, #53]	@ zero_extendqisi2
 107:rt_thread/src/ipc.c ****                 {
 1726              		.loc 1 107 55 view .LVU589
 1727 00b2 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 107:rt_thread/src/ipc.c ****                 {
 1728              		.loc 1 107 20 view .LVU590
 1729 00b6 9142     		cmp	r1, r2
 1730 00b8 01D3     		bcc	.L98
 102:rt_thread/src/ipc.c ****             {
 1731              		.loc 1 102 45 is_stmt 1 view .LVU591
 102:rt_thread/src/ipc.c ****             {
 1732              		.loc 1 102 47 is_stmt 0 view .LVU592
 1733 00ba 1B68     		ldr	r3, [r3]
 1734              	.LVL197:
 102:rt_thread/src/ipc.c ****             {
 1735              		.loc 1 102 47 view .LVU593
 1736 00bc F5E7     		b	.L75
 1737              	.LVL198:
 1738              	.L98:
 110:rt_thread/src/ipc.c ****                     break;
 1739              		.loc 1 110 21 is_stmt 1 view .LVU594
 1740 00be 04F11402 		add	r2, r4, #20
 1741              	.LVL199:
 1742              	.LBB165:
 1743              	.LBI165:
  73:rt_thread/include/rtservice.h **** {
 1744              		.loc 2 73 16 view .LVU595
 1745              	.LBB166:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1746              		.loc 2 75 5 view .LVU596
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1747              		.loc 2 75 6 is_stmt 0 view .LVU597
 1748 00c2 5968     		ldr	r1, [r3, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1749              		.loc 2 75 19 view .LVU598
 1750 00c4 0A60     		str	r2, [r1]
  76:rt_thread/include/rtservice.h **** 
 1751              		.loc 2 76 5 is_stmt 1 view .LVU599
  76:rt_thread/include/rtservice.h **** 
 1752              		.loc 2 76 16 is_stmt 0 view .LVU600
 1753 00c6 5968     		ldr	r1, [r3, #4]
ARM GAS  /tmp/ccDOLSjn.s 			page 67


  76:rt_thread/include/rtservice.h **** 
 1754              		.loc 2 76 13 view .LVU601
 1755 00c8 A161     		str	r1, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 1756              		.loc 2 78 5 is_stmt 1 view .LVU602
  78:rt_thread/include/rtservice.h ****     n->next = l;
 1757              		.loc 2 78 13 is_stmt 0 view .LVU603
 1758 00ca 5A60     		str	r2, [r3, #4]
  79:rt_thread/include/rtservice.h **** }
 1759              		.loc 2 79 5 is_stmt 1 view .LVU604
  79:rt_thread/include/rtservice.h **** }
 1760              		.loc 2 79 13 is_stmt 0 view .LVU605
 1761 00cc 6361     		str	r3, [r4, #20]
 1762              	.LVL200:
 1763              	.L77:
  79:rt_thread/include/rtservice.h **** }
 1764              		.loc 2 79 13 view .LVU606
 1765              	.LBE166:
 1766              	.LBE165:
 119:rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 1767              		.loc 1 119 13 is_stmt 1 view .LVU607
 119:rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 1768              		.loc 1 119 16 is_stmt 0 view .LVU608
 1769 00ce 9D42     		cmp	r5, r3
 1770 00d0 C3D1     		bne	.L74
 120:rt_thread/src/ipc.c ****         }
 1771              		.loc 1 120 17 is_stmt 1 view .LVU609
 1772 00d2 04F11403 		add	r3, r4, #20
 1773              	.LVL201:
 1774              	.LBB167:
 1775              	.LBI167:
  73:rt_thread/include/rtservice.h **** {
 1776              		.loc 2 73 16 view .LVU610
 1777              	.LBB168:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1778              		.loc 2 75 5 view .LVU611
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1779              		.loc 2 75 6 is_stmt 0 view .LVU612
 1780 00d6 6A68     		ldr	r2, [r5, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 1781              		.loc 2 75 19 view .LVU613
 1782 00d8 1360     		str	r3, [r2]
  76:rt_thread/include/rtservice.h **** 
 1783              		.loc 2 76 5 is_stmt 1 view .LVU614
  76:rt_thread/include/rtservice.h **** 
 1784              		.loc 2 76 16 is_stmt 0 view .LVU615
 1785 00da 6A68     		ldr	r2, [r5, #4]
  76:rt_thread/include/rtservice.h **** 
 1786              		.loc 2 76 13 view .LVU616
 1787 00dc A261     		str	r2, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 1788              		.loc 2 78 5 is_stmt 1 view .LVU617
  78:rt_thread/include/rtservice.h ****     n->next = l;
 1789              		.loc 2 78 13 is_stmt 0 view .LVU618
 1790 00de 6B60     		str	r3, [r5, #4]
  79:rt_thread/include/rtservice.h **** }
 1791              		.loc 2 79 5 is_stmt 1 view .LVU619
ARM GAS  /tmp/ccDOLSjn.s 			page 68


  79:rt_thread/include/rtservice.h **** }
 1792              		.loc 2 79 13 is_stmt 0 view .LVU620
 1793 00e0 6561     		str	r5, [r4, #20]
  80:rt_thread/include/rtservice.h **** 
 1794              		.loc 2 80 1 view .LVU621
 1795 00e2 BAE7     		b	.L74
 1796              	.LVL202:
 1797              	.L94:
  80:rt_thread/include/rtservice.h **** 
 1798              		.loc 2 80 1 view .LVU622
 1799              	.LBE168:
 1800              	.LBE167:
 1801              	.LBE164:
 1802              	.LBE169:
 1803              	.LBE170:
1531:rt_thread/src/ipc.c **** 
 1804              		.loc 1 1531 13 is_stmt 1 view .LVU623
1531:rt_thread/src/ipc.c **** 
 1805              		.loc 1 1531 26 is_stmt 0 view .LVU624
 1806 00e4 FFF7FEFF 		bl	rt_tick_get
 1807              	.LVL203:
 1808 00e8 8046     		mov	r8, r0
 1809              	.LVL204:
1534:rt_thread/src/ipc.c **** 
 1810              		.loc 1 1534 55 is_stmt 1 view .LVU625
1537:rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
 1811              		.loc 1 1537 13 view .LVU626
 1812 00ea 04F14405 		add	r5, r4, #68
 1813 00ee 01AA     		add	r2, sp, #4
 1814 00f0 0021     		movs	r1, #0
 1815 00f2 2846     		mov	r0, r5
 1816              	.LVL205:
1537:rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
 1817              		.loc 1 1537 13 is_stmt 0 view .LVU627
 1818 00f4 FFF7FEFF 		bl	rt_timer_control
 1819              	.LVL206:
1540:rt_thread/src/ipc.c ****         }
 1820              		.loc 1 1540 13 is_stmt 1 view .LVU628
 1821 00f8 2846     		mov	r0, r5
 1822 00fa FFF7FEFF 		bl	rt_timer_start
 1823              	.LVL207:
 1824 00fe AFE7     		b	.L79
 1825              	.LVL208:
 1826              	.L95:
1562:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 1827              		.loc 1 1562 13 view .LVU629
1562:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 1828              		.loc 1 1562 26 is_stmt 0 view .LVU630
 1829 0100 FFF7FEFF 		bl	rt_tick_get
 1830              	.LVL209:
1562:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 1831              		.loc 1 1562 24 view .LVU631
 1832 0104 A0EB0802 		sub	r2, r0, r8
 1833              	.LVL210:
1563:rt_thread/src/ipc.c ****             if (timeout < 0)
 1834              		.loc 1 1563 13 is_stmt 1 view .LVU632
1563:rt_thread/src/ipc.c ****             if (timeout < 0)
ARM GAS  /tmp/ccDOLSjn.s 			page 69


 1835              		.loc 1 1563 21 is_stmt 0 view .LVU633
 1836 0108 A8EB0000 		sub	r0, r8, r0
 1837 010c 019B     		ldr	r3, [sp, #4]
 1838 010e 1844     		add	r0, r0, r3
 1839 0110 0190     		str	r0, [sp, #4]
1564:rt_thread/src/ipc.c ****                 timeout = 0;
 1840              		.loc 1 1564 13 is_stmt 1 view .LVU634
1564:rt_thread/src/ipc.c ****                 timeout = 0;
 1841              		.loc 1 1564 16 is_stmt 0 view .LVU635
 1842 0112 0028     		cmp	r0, #0
 1843 0114 01DB     		blt	.L99
1562:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 1844              		.loc 1 1562 24 view .LVU636
 1845 0116 9046     		mov	r8, r2
 1846 0118 B0E7     		b	.L81
 1847              	.L99:
1565:rt_thread/src/ipc.c ****         }
 1848              		.loc 1 1565 17 is_stmt 1 view .LVU637
1565:rt_thread/src/ipc.c ****         }
 1849              		.loc 1 1565 25 is_stmt 0 view .LVU638
 1850 011a 0023     		movs	r3, #0
 1851 011c 0193     		str	r3, [sp, #4]
1562:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 1852              		.loc 1 1562 24 view .LVU639
 1853 011e 9046     		mov	r8, r2
 1854 0120 ACE7     		b	.L81
 1855              	.LVL211:
 1856              	.L96:
1570:rt_thread/src/ipc.c ****     /* increase input offset */
 1857              		.loc 1 1570 5 is_stmt 1 view .LVU640
1570:rt_thread/src/ipc.c ****     /* increase input offset */
 1858              		.loc 1 1570 7 is_stmt 0 view .LVU641
 1859 0122 F369     		ldr	r3, [r6, #28]
1570:rt_thread/src/ipc.c ****     /* increase input offset */
 1860              		.loc 1 1570 20 view .LVU642
 1861 0124 B28C     		ldrh	r2, [r6, #36]
1570:rt_thread/src/ipc.c ****     /* increase input offset */
 1862              		.loc 1 1570 33 view .LVU643
 1863 0126 43F82290 		str	r9, [r3, r2, lsl #2]
1572:rt_thread/src/ipc.c ****     if (mb->in_offset >= mb->size)
 1864              		.loc 1 1572 5 is_stmt 1 view .LVU644
1572:rt_thread/src/ipc.c ****     if (mb->in_offset >= mb->size)
 1865              		.loc 1 1572 10 is_stmt 0 view .LVU645
 1866 012a B38C     		ldrh	r3, [r6, #36]
1572:rt_thread/src/ipc.c ****     if (mb->in_offset >= mb->size)
 1867              		.loc 1 1572 5 view .LVU646
 1868 012c 0133     		adds	r3, r3, #1
 1869 012e 9BB2     		uxth	r3, r3
 1870 0130 B384     		strh	r3, [r6, #36]	@ movhi
1573:rt_thread/src/ipc.c ****         mb->in_offset = 0;
 1871              		.loc 1 1573 5 is_stmt 1 view .LVU647
1573:rt_thread/src/ipc.c ****         mb->in_offset = 0;
 1872              		.loc 1 1573 28 is_stmt 0 view .LVU648
 1873 0132 328C     		ldrh	r2, [r6, #32]
1573:rt_thread/src/ipc.c ****         mb->in_offset = 0;
 1874              		.loc 1 1573 8 view .LVU649
 1875 0134 9342     		cmp	r3, r2
ARM GAS  /tmp/ccDOLSjn.s 			page 70


 1876 0136 01D3     		bcc	.L83
1574:rt_thread/src/ipc.c **** 
 1877              		.loc 1 1574 9 is_stmt 1 view .LVU650
1574:rt_thread/src/ipc.c **** 
 1878              		.loc 1 1574 23 is_stmt 0 view .LVU651
 1879 0138 0023     		movs	r3, #0
 1880 013a B384     		strh	r3, [r6, #36]	@ movhi
 1881              	.L83:
1576:rt_thread/src/ipc.c ****     {
 1882              		.loc 1 1576 5 is_stmt 1 view .LVU652
1576:rt_thread/src/ipc.c ****     {
 1883              		.loc 1 1576 10 is_stmt 0 view .LVU653
 1884 013c 738C     		ldrh	r3, [r6, #34]
1576:rt_thread/src/ipc.c ****     {
 1885              		.loc 1 1576 7 view .LVU654
 1886 013e 4FF6FF72 		movw	r2, #65535
 1887 0142 9342     		cmp	r3, r2
 1888 0144 10D0     		beq	.L84
1579:rt_thread/src/ipc.c ****     }
 1889              		.loc 1 1579 9 is_stmt 1 view .LVU655
1579:rt_thread/src/ipc.c ****     }
 1890              		.loc 1 1579 19 is_stmt 0 view .LVU656
 1891 0146 0133     		adds	r3, r3, #1
 1892 0148 7384     		strh	r3, [r6, #34]	@ movhi
1588:rt_thread/src/ipc.c ****     {
 1893              		.loc 1 1588 5 is_stmt 1 view .LVU657
1588:rt_thread/src/ipc.c ****     {
 1894              		.loc 1 1588 26 is_stmt 0 view .LVU658
 1895 014a 06F11403 		add	r3, r6, #20
 1896              	.LVL212:
 1897              	.LBB171:
 1898              	.LBI171:
  98:rt_thread/include/rtservice.h **** {
 1899              		.loc 2 98 15 is_stmt 1 view .LVU659
 1900              	.LBB172:
 1901              		.loc 2 100 5 view .LVU660
 1902              		.loc 2 100 13 is_stmt 0 view .LVU661
 1903 014e 7069     		ldr	r0, [r6, #20]
 1904              	.LVL213:
 1905              		.loc 2 100 13 view .LVU662
 1906              	.LBE172:
 1907              	.LBE171:
1588:rt_thread/src/ipc.c ****     {
 1908              		.loc 1 1588 8 view .LVU663
 1909 0150 8342     		cmp	r3, r0
 1910 0152 0FD0     		beq	.L100
1590:rt_thread/src/ipc.c **** 
 1911              		.loc 1 1590 9 is_stmt 1 view .LVU664
 1912              	.LVL214:
 1913              	.LBB173:
 1914              	.LBI173:
 140:rt_thread/src/ipc.c **** {
 1915              		.loc 1 140 20 view .LVU665
 1916              	.LBB174:
 142:rt_thread/src/ipc.c **** 
 1917              		.loc 1 142 5 view .LVU666
 145:rt_thread/src/ipc.c **** 
ARM GAS  /tmp/ccDOLSjn.s 			page 71


 1918              		.loc 1 145 5 view .LVU667
 147:rt_thread/src/ipc.c **** 
 1919              		.loc 1 147 69 view .LVU668
 150:rt_thread/src/ipc.c **** 
 1920              		.loc 1 150 5 view .LVU669
 1921 0154 1438     		subs	r0, r0, #20
 1922              	.LVL215:
 150:rt_thread/src/ipc.c **** 
 1923              		.loc 1 150 5 is_stmt 0 view .LVU670
 1924 0156 FFF7FEFF 		bl	rt_thread_resume
 1925              	.LVL216:
 152:rt_thread/src/ipc.c **** }
 1926              		.loc 1 152 5 is_stmt 1 view .LVU671
 152:rt_thread/src/ipc.c **** }
 1927              		.loc 1 152 5 is_stmt 0 view .LVU672
 1928              	.LBE174:
 1929              	.LBE173:
1593:rt_thread/src/ipc.c **** 
 1930              		.loc 1 1593 9 is_stmt 1 view .LVU673
 1931 015a 3846     		mov	r0, r7
 1932 015c FFF7FEFF 		bl	rt_hw_interrupt_enable
 1933              	.LVL217:
1595:rt_thread/src/ipc.c **** 
 1934              		.loc 1 1595 9 view .LVU674
 1935 0160 FFF7FEFF 		bl	rt_schedule
 1936              	.LVL218:
1597:rt_thread/src/ipc.c ****     }
 1937              		.loc 1 1597 9 view .LVU675
1597:rt_thread/src/ipc.c ****     }
 1938              		.loc 1 1597 16 is_stmt 0 view .LVU676
 1939 0164 0020     		movs	r0, #0
 1940 0166 6DE7     		b	.L68
 1941              	.L84:
1583:rt_thread/src/ipc.c ****         return -RT_EFULL; /* value overflowed */
 1942              		.loc 1 1583 9 is_stmt 1 view .LVU677
 1943 0168 3846     		mov	r0, r7
 1944 016a FFF7FEFF 		bl	rt_hw_interrupt_enable
 1945              	.LVL219:
1584:rt_thread/src/ipc.c ****     }
 1946              		.loc 1 1584 9 view .LVU678
1584:rt_thread/src/ipc.c ****     }
 1947              		.loc 1 1584 16 is_stmt 0 view .LVU679
 1948 016e 6FF00200 		mvn	r0, #2
 1949 0172 67E7     		b	.L68
 1950              	.L100:
1601:rt_thread/src/ipc.c **** 
 1951              		.loc 1 1601 5 is_stmt 1 view .LVU680
 1952 0174 3846     		mov	r0, r7
 1953 0176 FFF7FEFF 		bl	rt_hw_interrupt_enable
 1954              	.LVL220:
1603:rt_thread/src/ipc.c **** }
 1955              		.loc 1 1603 5 view .LVU681
1603:rt_thread/src/ipc.c **** }
 1956              		.loc 1 1603 12 is_stmt 0 view .LVU682
 1957 017a 0020     		movs	r0, #0
 1958 017c 62E7     		b	.L68
 1959              		.cfi_endproc
ARM GAS  /tmp/ccDOLSjn.s 			page 72


 1960              	.LFE31:
 1962              		.section	.text.rt_mb_send,"ax",%progbits
 1963              		.align	1
 1964              		.global	rt_mb_send
 1965              		.syntax unified
 1966              		.thumb
 1967              		.thumb_func
 1969              	rt_mb_send:
 1970              	.LVL221:
 1971              	.LFB32:
1605:rt_thread/src/ipc.c **** 
1606:rt_thread/src/ipc.c **** /**
1607:rt_thread/src/ipc.c ****  * This function will send a mail to mailbox object, if there are threads
1608:rt_thread/src/ipc.c ****  * suspended on mailbox object, it will be waked up. This function will return
1609:rt_thread/src/ipc.c ****  * immediately, if you want blocking send, use rt_mb_send_wait instead.
1610:rt_thread/src/ipc.c ****  *
1611:rt_thread/src/ipc.c ****  * @param mb the mailbox object
1612:rt_thread/src/ipc.c ****  * @param value the mail
1613:rt_thread/src/ipc.c ****  *
1614:rt_thread/src/ipc.c ****  * @return the error code
1615:rt_thread/src/ipc.c ****  */
1616:rt_thread/src/ipc.c **** rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value)
1617:rt_thread/src/ipc.c **** {
 1972              		.loc 1 1617 1 is_stmt 1 view -0
 1973              		.cfi_startproc
 1974              		@ args = 0, pretend = 0, frame = 0
 1975              		@ frame_needed = 0, uses_anonymous_args = 0
 1976              		.loc 1 1617 1 is_stmt 0 view .LVU684
 1977 0000 08B5     		push	{r3, lr}
 1978              	.LCFI20:
 1979              		.cfi_def_cfa_offset 8
 1980              		.cfi_offset 3, -8
 1981              		.cfi_offset 14, -4
1618:rt_thread/src/ipc.c ****     return rt_mb_send_wait(mb, value, 0);
 1982              		.loc 1 1618 5 is_stmt 1 view .LVU685
 1983              		.loc 1 1618 12 is_stmt 0 view .LVU686
 1984 0002 0022     		movs	r2, #0
 1985 0004 FFF7FEFF 		bl	rt_mb_send_wait
 1986              	.LVL222:
1619:rt_thread/src/ipc.c **** }
 1987              		.loc 1 1619 1 view .LVU687
 1988 0008 08BD     		pop	{r3, pc}
 1989              		.cfi_endproc
 1990              	.LFE32:
 1992              		.section	.text.rt_mb_recv,"ax",%progbits
 1993              		.align	1
 1994              		.global	rt_mb_recv
 1995              		.syntax unified
 1996              		.thumb
 1997              		.thumb_func
 1999              	rt_mb_recv:
 2000              	.LVL223:
 2001              	.LFB33:
1620:rt_thread/src/ipc.c **** 
1621:rt_thread/src/ipc.c **** /**
1622:rt_thread/src/ipc.c ****  * This function will receive a mail from mailbox object, if there is no mail
1623:rt_thread/src/ipc.c ****  * in mailbox object, the thread shall wait for a specified time.
ARM GAS  /tmp/ccDOLSjn.s 			page 73


1624:rt_thread/src/ipc.c ****  *
1625:rt_thread/src/ipc.c ****  * @param mb the mailbox object
1626:rt_thread/src/ipc.c ****  * @param value the received mail will be saved in
1627:rt_thread/src/ipc.c ****  * @param timeout the waiting time
1628:rt_thread/src/ipc.c ****  *
1629:rt_thread/src/ipc.c ****  * @return the error code
1630:rt_thread/src/ipc.c ****  */
1631:rt_thread/src/ipc.c **** rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout)
1632:rt_thread/src/ipc.c **** {
 2002              		.loc 1 1632 1 is_stmt 1 view -0
 2003              		.cfi_startproc
 2004              		@ args = 0, pretend = 0, frame = 8
 2005              		@ frame_needed = 0, uses_anonymous_args = 0
 2006              		.loc 1 1632 1 is_stmt 0 view .LVU689
 2007 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 2008              	.LCFI21:
 2009              		.cfi_def_cfa_offset 32
 2010              		.cfi_offset 4, -32
 2011              		.cfi_offset 5, -28
 2012              		.cfi_offset 6, -24
 2013              		.cfi_offset 7, -20
 2014              		.cfi_offset 8, -16
 2015              		.cfi_offset 9, -12
 2016              		.cfi_offset 10, -8
 2017              		.cfi_offset 14, -4
 2018 0004 82B0     		sub	sp, sp, #8
 2019              	.LCFI22:
 2020              		.cfi_def_cfa_offset 40
 2021 0006 0646     		mov	r6, r0
 2022 0008 8946     		mov	r9, r1
 2023 000a 0192     		str	r2, [sp, #4]
1633:rt_thread/src/ipc.c ****     struct rt_thread *thread;
 2024              		.loc 1 1633 5 is_stmt 1 view .LVU690
1634:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 2025              		.loc 1 1634 5 view .LVU691
1635:rt_thread/src/ipc.c ****     rt_uint32_t tick_delta;
 2026              		.loc 1 1635 5 view .LVU692
1636:rt_thread/src/ipc.c **** 
1637:rt_thread/src/ipc.c ****     /* parameter check */
1638:rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
 2027              		.loc 1 1638 29 view .LVU693
1639:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
 2028              		.loc 1 1639 81 view .LVU694
1640:rt_thread/src/ipc.c **** 
1641:rt_thread/src/ipc.c ****     /* initialize delta tick */
1642:rt_thread/src/ipc.c ****     tick_delta = 0;
 2029              		.loc 1 1642 5 view .LVU695
 2030              	.LVL224:
1643:rt_thread/src/ipc.c ****     /* get current thread */
1644:rt_thread/src/ipc.c ****     thread = rt_thread_self();
 2031              		.loc 1 1644 5 view .LVU696
 2032              		.loc 1 1644 14 is_stmt 0 view .LVU697
 2033 000c FFF7FEFF 		bl	rt_thread_self
 2034              	.LVL225:
 2035              		.loc 1 1644 14 view .LVU698
 2036 0010 0446     		mov	r4, r0
 2037              	.LVL226:
ARM GAS  /tmp/ccDOLSjn.s 			page 74


1645:rt_thread/src/ipc.c **** 
1646:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
 2038              		.loc 1 1646 72 is_stmt 1 view .LVU699
1647:rt_thread/src/ipc.c **** 
1648:rt_thread/src/ipc.c ****     /* disable interrupt */
1649:rt_thread/src/ipc.c ****     temp = rt_hw_interrupt_disable();
 2039              		.loc 1 1649 5 view .LVU700
 2040              		.loc 1 1649 12 is_stmt 0 view .LVU701
 2041 0012 FFF7FEFF 		bl	rt_hw_interrupt_disable
 2042              	.LVL227:
 2043              		.loc 1 1649 10 view .LVU702
 2044 0016 0746     		mov	r7, r0
 2045              	.LVL228:
1650:rt_thread/src/ipc.c **** 
1651:rt_thread/src/ipc.c ****     /* for non-blocking call */
1652:rt_thread/src/ipc.c ****     if (mb->entry == 0 && timeout == 0)
 2046              		.loc 1 1652 5 is_stmt 1 view .LVU703
 2047              		.loc 1 1652 11 is_stmt 0 view .LVU704
 2048 0018 738C     		ldrh	r3, [r6, #34]
 2049              		.loc 1 1652 8 view .LVU705
 2050 001a 002B     		cmp	r3, #0
 2051 001c 7DD1     		bne	.L121
 2052              		.loc 1 1652 35 discriminator 1 view .LVU706
 2053 001e 019B     		ldr	r3, [sp, #4]
 2054              		.loc 1 1652 24 discriminator 1 view .LVU707
 2055 0020 13B1     		cbz	r3, .L125
 2056 0022 4FF00008 		mov	r8, #0
 2057 0026 26E0     		b	.L116
 2058              	.L125:
1653:rt_thread/src/ipc.c ****     {
1654:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
 2059              		.loc 1 1654 9 is_stmt 1 view .LVU708
 2060 0028 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2061              	.LVL229:
1655:rt_thread/src/ipc.c **** 
1656:rt_thread/src/ipc.c ****         return -RT_ETIMEOUT;
 2062              		.loc 1 1656 9 view .LVU709
 2063              		.loc 1 1656 16 is_stmt 0 view .LVU710
 2064 002c 6FF00100 		mvn	r0, #1
 2065 0030 05E0     		b	.L103
 2066              	.LVL230:
 2067              	.L129:
1657:rt_thread/src/ipc.c ****     }
1658:rt_thread/src/ipc.c **** 
1659:rt_thread/src/ipc.c ****     /* mailbox is empty */
1660:rt_thread/src/ipc.c ****     while (mb->entry == 0)
1661:rt_thread/src/ipc.c ****     {
1662:rt_thread/src/ipc.c ****         /* reset error number in thread */
1663:rt_thread/src/ipc.c ****         thread->error = RT_EOK;
1664:rt_thread/src/ipc.c **** 
1665:rt_thread/src/ipc.c ****         /* no waiting, return timeout */
1666:rt_thread/src/ipc.c ****         if (timeout == 0)
1667:rt_thread/src/ipc.c ****         {
1668:rt_thread/src/ipc.c ****             /* enable interrupt */
1669:rt_thread/src/ipc.c ****             rt_hw_interrupt_enable(temp);
 2068              		.loc 1 1669 13 is_stmt 1 view .LVU711
 2069 0032 3846     		mov	r0, r7
ARM GAS  /tmp/ccDOLSjn.s 			page 75


 2070 0034 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2071              	.LVL231:
1670:rt_thread/src/ipc.c **** 
1671:rt_thread/src/ipc.c ****             thread->error = -RT_ETIMEOUT;
 2072              		.loc 1 1671 13 view .LVU712
 2073              		.loc 1 1671 27 is_stmt 0 view .LVU713
 2074 0038 6FF00100 		mvn	r0, #1
 2075 003c 2063     		str	r0, [r4, #48]
1672:rt_thread/src/ipc.c **** 
1673:rt_thread/src/ipc.c ****             return -RT_ETIMEOUT;
 2076              		.loc 1 1673 13 is_stmt 1 view .LVU714
 2077              	.LVL232:
 2078              	.L103:
1674:rt_thread/src/ipc.c ****         }
1675:rt_thread/src/ipc.c **** 
1676:rt_thread/src/ipc.c ****         RT_DEBUG_IN_THREAD_CONTEXT;
1677:rt_thread/src/ipc.c ****         /* suspend current thread */
1678:rt_thread/src/ipc.c ****         rt_ipc_list_suspend(&(mb->parent.suspend_thread),
1679:rt_thread/src/ipc.c ****                             thread,
1680:rt_thread/src/ipc.c ****                             mb->parent.parent.flag);
1681:rt_thread/src/ipc.c **** 
1682:rt_thread/src/ipc.c ****         /* has waiting time, start thread timer */
1683:rt_thread/src/ipc.c ****         if (timeout > 0)
1684:rt_thread/src/ipc.c ****         {
1685:rt_thread/src/ipc.c ****             /* get the start tick of timer */
1686:rt_thread/src/ipc.c ****             tick_delta = rt_tick_get();
1687:rt_thread/src/ipc.c **** 
1688:rt_thread/src/ipc.c ****             RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
1689:rt_thread/src/ipc.c ****                                         thread->name));
1690:rt_thread/src/ipc.c **** 
1691:rt_thread/src/ipc.c ****             /* reset the timeout of thread timer and start it */
1692:rt_thread/src/ipc.c ****             rt_timer_control(&(thread->thread_timer),
1693:rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
1694:rt_thread/src/ipc.c ****                              &timeout);
1695:rt_thread/src/ipc.c ****             rt_timer_start(&(thread->thread_timer));
1696:rt_thread/src/ipc.c ****         }
1697:rt_thread/src/ipc.c **** 
1698:rt_thread/src/ipc.c ****         /* enable interrupt */
1699:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1700:rt_thread/src/ipc.c **** 
1701:rt_thread/src/ipc.c ****         /* re-schedule */
1702:rt_thread/src/ipc.c ****         rt_schedule();
1703:rt_thread/src/ipc.c **** 
1704:rt_thread/src/ipc.c ****         /* resume from suspend state */
1705:rt_thread/src/ipc.c ****         if (thread->error != RT_EOK)
1706:rt_thread/src/ipc.c ****         {
1707:rt_thread/src/ipc.c ****             /* return error */
1708:rt_thread/src/ipc.c ****             return thread->error;
1709:rt_thread/src/ipc.c ****         }
1710:rt_thread/src/ipc.c **** 
1711:rt_thread/src/ipc.c ****         /* disable interrupt */
1712:rt_thread/src/ipc.c ****         temp = rt_hw_interrupt_disable();
1713:rt_thread/src/ipc.c **** 
1714:rt_thread/src/ipc.c ****         /* if it's not waiting forever and then re-calculate timeout tick */
1715:rt_thread/src/ipc.c ****         if (timeout > 0)
1716:rt_thread/src/ipc.c ****         {
1717:rt_thread/src/ipc.c ****             tick_delta = rt_tick_get() - tick_delta;
ARM GAS  /tmp/ccDOLSjn.s 			page 76


1718:rt_thread/src/ipc.c ****             timeout -= tick_delta;
1719:rt_thread/src/ipc.c ****             if (timeout < 0)
1720:rt_thread/src/ipc.c ****                 timeout = 0;
1721:rt_thread/src/ipc.c ****         }
1722:rt_thread/src/ipc.c ****     }
1723:rt_thread/src/ipc.c **** 
1724:rt_thread/src/ipc.c ****     /* fill ptr */
1725:rt_thread/src/ipc.c ****     *value = mb->msg_pool[mb->out_offset];
1726:rt_thread/src/ipc.c **** 
1727:rt_thread/src/ipc.c ****     /* increase output offset */
1728:rt_thread/src/ipc.c ****     ++ mb->out_offset;
1729:rt_thread/src/ipc.c ****     if (mb->out_offset >= mb->size)
1730:rt_thread/src/ipc.c ****         mb->out_offset = 0;
1731:rt_thread/src/ipc.c **** 
1732:rt_thread/src/ipc.c ****     /* decrease message entry */
1733:rt_thread/src/ipc.c ****     if(mb->entry > 0)
1734:rt_thread/src/ipc.c ****     {
1735:rt_thread/src/ipc.c ****         mb->entry --;
1736:rt_thread/src/ipc.c ****     }
1737:rt_thread/src/ipc.c **** 
1738:rt_thread/src/ipc.c ****     /* resume suspended thread */
1739:rt_thread/src/ipc.c ****     if (!rt_list_isempty(&(mb->suspend_sender_thread)))
1740:rt_thread/src/ipc.c ****     {
1741:rt_thread/src/ipc.c ****         rt_ipc_list_resume(&(mb->suspend_sender_thread));
1742:rt_thread/src/ipc.c **** 
1743:rt_thread/src/ipc.c ****         /* enable interrupt */
1744:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(temp);
1745:rt_thread/src/ipc.c **** 
1746:rt_thread/src/ipc.c ****         RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
1747:rt_thread/src/ipc.c **** 
1748:rt_thread/src/ipc.c ****         rt_schedule();
1749:rt_thread/src/ipc.c **** 
1750:rt_thread/src/ipc.c ****         return RT_EOK;
1751:rt_thread/src/ipc.c ****     }
1752:rt_thread/src/ipc.c **** 
1753:rt_thread/src/ipc.c ****     /* enable interrupt */
1754:rt_thread/src/ipc.c ****     rt_hw_interrupt_enable(temp);
1755:rt_thread/src/ipc.c **** 
1756:rt_thread/src/ipc.c ****     RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
1757:rt_thread/src/ipc.c **** 
1758:rt_thread/src/ipc.c ****     return RT_EOK;
1759:rt_thread/src/ipc.c **** }
 2079              		.loc 1 1759 1 is_stmt 0 view .LVU715
 2080 003e 02B0     		add	sp, sp, #8
 2081              	.LCFI23:
 2082              		.cfi_remember_state
 2083              		.cfi_def_cfa_offset 32
 2084              		@ sp needed
 2085 0040 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 2086              	.LVL233:
 2087              	.L107:
 2088              	.LCFI24:
 2089              		.cfi_restore_state
 2090              	.LBB188:
 2091              	.LBB189:
  93:rt_thread/src/ipc.c ****         break;
 2092              		.loc 1 93 9 is_stmt 1 view .LVU716
ARM GAS  /tmp/ccDOLSjn.s 			page 77


 2093 0044 04F11403 		add	r3, r4, #20
 2094              	.LVL234:
 2095              	.LBB190:
 2096              	.LBI190:
  73:rt_thread/include/rtservice.h **** {
 2097              		.loc 2 73 16 view .LVU717
 2098              	.LBB191:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2099              		.loc 2 75 5 view .LVU718
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2100              		.loc 2 75 6 is_stmt 0 view .LVU719
 2101 0048 6A68     		ldr	r2, [r5, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2102              		.loc 2 75 19 view .LVU720
 2103 004a 1360     		str	r3, [r2]
  76:rt_thread/include/rtservice.h **** 
 2104              		.loc 2 76 5 is_stmt 1 view .LVU721
  76:rt_thread/include/rtservice.h **** 
 2105              		.loc 2 76 16 is_stmt 0 view .LVU722
 2106 004c 6A68     		ldr	r2, [r5, #4]
  76:rt_thread/include/rtservice.h **** 
 2107              		.loc 2 76 13 view .LVU723
 2108 004e A261     		str	r2, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 2109              		.loc 2 78 5 is_stmt 1 view .LVU724
  78:rt_thread/include/rtservice.h ****     n->next = l;
 2110              		.loc 2 78 13 is_stmt 0 view .LVU725
 2111 0050 6B60     		str	r3, [r5, #4]
  79:rt_thread/include/rtservice.h **** }
 2112              		.loc 2 79 5 is_stmt 1 view .LVU726
  79:rt_thread/include/rtservice.h **** }
 2113              		.loc 2 79 13 is_stmt 0 view .LVU727
 2114 0052 6561     		str	r5, [r4, #20]
 2115              	.LVL235:
 2116              	.L109:
  79:rt_thread/include/rtservice.h **** }
 2117              		.loc 2 79 13 view .LVU728
 2118              	.LBE191:
 2119              	.LBE190:
 128:rt_thread/src/ipc.c **** }
 2120              		.loc 1 128 5 is_stmt 1 view .LVU729
 128:rt_thread/src/ipc.c **** }
 2121              		.loc 1 128 5 is_stmt 0 view .LVU730
 2122              	.LBE189:
 2123              	.LBE188:
1683:rt_thread/src/ipc.c ****         {
 2124              		.loc 1 1683 9 is_stmt 1 view .LVU731
1683:rt_thread/src/ipc.c ****         {
 2125              		.loc 1 1683 21 is_stmt 0 view .LVU732
 2126 0054 019B     		ldr	r3, [sp, #4]
1683:rt_thread/src/ipc.c ****         {
 2127              		.loc 1 1683 12 view .LVU733
 2128 0056 002B     		cmp	r3, #0
 2129 0058 40DC     		bgt	.L126
 2130              	.L114:
1699:rt_thread/src/ipc.c **** 
 2131              		.loc 1 1699 9 is_stmt 1 view .LVU734
ARM GAS  /tmp/ccDOLSjn.s 			page 78


 2132 005a 3846     		mov	r0, r7
 2133 005c FFF7FEFF 		bl	rt_hw_interrupt_enable
 2134              	.LVL236:
1702:rt_thread/src/ipc.c **** 
 2135              		.loc 1 1702 9 view .LVU735
 2136 0060 FFF7FEFF 		bl	rt_schedule
 2137              	.LVL237:
1705:rt_thread/src/ipc.c ****         {
 2138              		.loc 1 1705 9 view .LVU736
1705:rt_thread/src/ipc.c ****         {
 2139              		.loc 1 1705 19 is_stmt 0 view .LVU737
 2140 0064 206B     		ldr	r0, [r4, #48]
1705:rt_thread/src/ipc.c ****         {
 2141              		.loc 1 1705 12 view .LVU738
 2142 0066 0028     		cmp	r0, #0
 2143 0068 E9D1     		bne	.L103
1712:rt_thread/src/ipc.c **** 
 2144              		.loc 1 1712 9 is_stmt 1 view .LVU739
1712:rt_thread/src/ipc.c **** 
 2145              		.loc 1 1712 16 is_stmt 0 view .LVU740
 2146 006a FFF7FEFF 		bl	rt_hw_interrupt_disable
 2147              	.LVL238:
 2148 006e 0746     		mov	r7, r0
 2149              	.LVL239:
1715:rt_thread/src/ipc.c ****         {
 2150              		.loc 1 1715 9 is_stmt 1 view .LVU741
1715:rt_thread/src/ipc.c ****         {
 2151              		.loc 1 1715 21 is_stmt 0 view .LVU742
 2152 0070 019B     		ldr	r3, [sp, #4]
1715:rt_thread/src/ipc.c ****         {
 2153              		.loc 1 1715 12 view .LVU743
 2154 0072 002B     		cmp	r3, #0
 2155 0074 40DC     		bgt	.L127
 2156              	.LVL240:
 2157              	.L116:
1660:rt_thread/src/ipc.c ****     {
 2158              		.loc 1 1660 11 is_stmt 1 view .LVU744
1660:rt_thread/src/ipc.c ****     {
 2159              		.loc 1 1660 14 is_stmt 0 view .LVU745
 2160 0076 738C     		ldrh	r3, [r6, #34]
1660:rt_thread/src/ipc.c ****     {
 2161              		.loc 1 1660 11 view .LVU746
 2162 0078 002B     		cmp	r3, #0
 2163 007a 51D1     		bne	.L128
1663:rt_thread/src/ipc.c **** 
 2164              		.loc 1 1663 9 is_stmt 1 view .LVU747
1663:rt_thread/src/ipc.c **** 
 2165              		.loc 1 1663 23 is_stmt 0 view .LVU748
 2166 007c 0023     		movs	r3, #0
 2167 007e 2363     		str	r3, [r4, #48]
1666:rt_thread/src/ipc.c ****         {
 2168              		.loc 1 1666 9 is_stmt 1 view .LVU749
1666:rt_thread/src/ipc.c ****         {
 2169              		.loc 1 1666 21 is_stmt 0 view .LVU750
 2170 0080 019B     		ldr	r3, [sp, #4]
1666:rt_thread/src/ipc.c ****         {
 2171              		.loc 1 1666 12 view .LVU751
ARM GAS  /tmp/ccDOLSjn.s 			page 79


 2172 0082 002B     		cmp	r3, #0
 2173 0084 D5D0     		beq	.L129
1676:rt_thread/src/ipc.c ****         /* suspend current thread */
 2174              		.loc 1 1676 35 is_stmt 1 view .LVU752
1678:rt_thread/src/ipc.c ****                             thread,
 2175              		.loc 1 1678 9 view .LVU753
 2176 0086 06F11405 		add	r5, r6, #20
 2177 008a 96F809A0 		ldrb	r10, [r6, #9]	@ zero_extendqisi2
 2178              	.LVL241:
 2179              	.LBB198:
 2180              	.LBI188:
  83:rt_thread/src/ipc.c ****                                        struct rt_thread *thread,
 2181              		.loc 1 83 20 view .LVU754
 2182              	.LBB197:
  88:rt_thread/src/ipc.c **** 
 2183              		.loc 1 88 5 view .LVU755
 2184 008e 2046     		mov	r0, r4
 2185 0090 FFF7FEFF 		bl	rt_thread_suspend
 2186              	.LVL242:
  90:rt_thread/src/ipc.c ****     {
 2187              		.loc 1 90 5 view .LVU756
 2188 0094 BAF1000F 		cmp	r10, #0
 2189 0098 D4D0     		beq	.L107
 2190 009a BAF1010F 		cmp	r10, #1
 2191 009e D9D1     		bne	.L109
 2192              	.LBB192:
  98:rt_thread/src/ipc.c ****             struct rt_thread *sthread;
 2193              		.loc 1 98 13 view .LVU757
  99:rt_thread/src/ipc.c **** 
 2194              		.loc 1 99 13 view .LVU758
 102:rt_thread/src/ipc.c ****             {
 2195              		.loc 1 102 13 view .LVU759
 102:rt_thread/src/ipc.c ****             {
 2196              		.loc 1 102 20 is_stmt 0 view .LVU760
 2197 00a0 7369     		ldr	r3, [r6, #20]
 2198              	.LVL243:
 2199              	.L110:
 102:rt_thread/src/ipc.c ****             {
 2200              		.loc 1 102 34 is_stmt 1 view .LVU761
 102:rt_thread/src/ipc.c ****             {
 2201              		.loc 1 102 13 is_stmt 0 view .LVU762
 2202 00a2 9D42     		cmp	r5, r3
 2203 00a4 0FD0     		beq	.L112
 104:rt_thread/src/ipc.c **** 
 2204              		.loc 1 104 17 is_stmt 1 view .LVU763
 2205              	.LVL244:
 107:rt_thread/src/ipc.c ****                 {
 2206              		.loc 1 107 17 view .LVU764
 107:rt_thread/src/ipc.c ****                 {
 2207              		.loc 1 107 27 is_stmt 0 view .LVU765
 2208 00a6 94F83510 		ldrb	r1, [r4, #53]	@ zero_extendqisi2
 107:rt_thread/src/ipc.c ****                 {
 2209              		.loc 1 107 55 view .LVU766
 2210 00aa 93F82120 		ldrb	r2, [r3, #33]	@ zero_extendqisi2
 107:rt_thread/src/ipc.c ****                 {
 2211              		.loc 1 107 20 view .LVU767
 2212 00ae 9142     		cmp	r1, r2
ARM GAS  /tmp/ccDOLSjn.s 			page 80


 2213 00b0 01D3     		bcc	.L130
 102:rt_thread/src/ipc.c ****             {
 2214              		.loc 1 102 45 is_stmt 1 view .LVU768
 102:rt_thread/src/ipc.c ****             {
 2215              		.loc 1 102 47 is_stmt 0 view .LVU769
 2216 00b2 1B68     		ldr	r3, [r3]
 2217              	.LVL245:
 102:rt_thread/src/ipc.c ****             {
 2218              		.loc 1 102 47 view .LVU770
 2219 00b4 F5E7     		b	.L110
 2220              	.LVL246:
 2221              	.L130:
 110:rt_thread/src/ipc.c ****                     break;
 2222              		.loc 1 110 21 is_stmt 1 view .LVU771
 2223 00b6 04F11402 		add	r2, r4, #20
 2224              	.LVL247:
 2225              	.LBB193:
 2226              	.LBI193:
  73:rt_thread/include/rtservice.h **** {
 2227              		.loc 2 73 16 view .LVU772
 2228              	.LBB194:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2229              		.loc 2 75 5 view .LVU773
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2230              		.loc 2 75 6 is_stmt 0 view .LVU774
 2231 00ba 5968     		ldr	r1, [r3, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2232              		.loc 2 75 19 view .LVU775
 2233 00bc 0A60     		str	r2, [r1]
  76:rt_thread/include/rtservice.h **** 
 2234              		.loc 2 76 5 is_stmt 1 view .LVU776
  76:rt_thread/include/rtservice.h **** 
 2235              		.loc 2 76 16 is_stmt 0 view .LVU777
 2236 00be 5968     		ldr	r1, [r3, #4]
  76:rt_thread/include/rtservice.h **** 
 2237              		.loc 2 76 13 view .LVU778
 2238 00c0 A161     		str	r1, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 2239              		.loc 2 78 5 is_stmt 1 view .LVU779
  78:rt_thread/include/rtservice.h ****     n->next = l;
 2240              		.loc 2 78 13 is_stmt 0 view .LVU780
 2241 00c2 5A60     		str	r2, [r3, #4]
  79:rt_thread/include/rtservice.h **** }
 2242              		.loc 2 79 5 is_stmt 1 view .LVU781
  79:rt_thread/include/rtservice.h **** }
 2243              		.loc 2 79 13 is_stmt 0 view .LVU782
 2244 00c4 6361     		str	r3, [r4, #20]
 2245              	.LVL248:
 2246              	.L112:
  79:rt_thread/include/rtservice.h **** }
 2247              		.loc 2 79 13 view .LVU783
 2248              	.LBE194:
 2249              	.LBE193:
 119:rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 2250              		.loc 1 119 13 is_stmt 1 view .LVU784
 119:rt_thread/src/ipc.c ****                 rt_list_insert_before(list, &(thread->tlist));
 2251              		.loc 1 119 16 is_stmt 0 view .LVU785
ARM GAS  /tmp/ccDOLSjn.s 			page 81


 2252 00c6 9D42     		cmp	r5, r3
 2253 00c8 C4D1     		bne	.L109
 120:rt_thread/src/ipc.c ****         }
 2254              		.loc 1 120 17 is_stmt 1 view .LVU786
 2255 00ca 04F11403 		add	r3, r4, #20
 2256              	.LVL249:
 2257              	.LBB195:
 2258              	.LBI195:
  73:rt_thread/include/rtservice.h **** {
 2259              		.loc 2 73 16 view .LVU787
 2260              	.LBB196:
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2261              		.loc 2 75 5 view .LVU788
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2262              		.loc 2 75 6 is_stmt 0 view .LVU789
 2263 00ce 6A68     		ldr	r2, [r5, #4]
  75:rt_thread/include/rtservice.h ****     n->prev = l->prev;
 2264              		.loc 2 75 19 view .LVU790
 2265 00d0 1360     		str	r3, [r2]
  76:rt_thread/include/rtservice.h **** 
 2266              		.loc 2 76 5 is_stmt 1 view .LVU791
  76:rt_thread/include/rtservice.h **** 
 2267              		.loc 2 76 16 is_stmt 0 view .LVU792
 2268 00d2 6A68     		ldr	r2, [r5, #4]
  76:rt_thread/include/rtservice.h **** 
 2269              		.loc 2 76 13 view .LVU793
 2270 00d4 A261     		str	r2, [r4, #24]
  78:rt_thread/include/rtservice.h ****     n->next = l;
 2271              		.loc 2 78 5 is_stmt 1 view .LVU794
  78:rt_thread/include/rtservice.h ****     n->next = l;
 2272              		.loc 2 78 13 is_stmt 0 view .LVU795
 2273 00d6 6B60     		str	r3, [r5, #4]
  79:rt_thread/include/rtservice.h **** }
 2274              		.loc 2 79 5 is_stmt 1 view .LVU796
  79:rt_thread/include/rtservice.h **** }
 2275              		.loc 2 79 13 is_stmt 0 view .LVU797
 2276 00d8 6561     		str	r5, [r4, #20]
  80:rt_thread/include/rtservice.h **** 
 2277              		.loc 2 80 1 view .LVU798
 2278 00da BBE7     		b	.L109
 2279              	.LVL250:
 2280              	.L126:
  80:rt_thread/include/rtservice.h **** 
 2281              		.loc 2 80 1 view .LVU799
 2282              	.LBE196:
 2283              	.LBE195:
 2284              	.LBE192:
 2285              	.LBE197:
 2286              	.LBE198:
1686:rt_thread/src/ipc.c **** 
 2287              		.loc 1 1686 13 is_stmt 1 view .LVU800
1686:rt_thread/src/ipc.c **** 
 2288              		.loc 1 1686 26 is_stmt 0 view .LVU801
 2289 00dc FFF7FEFF 		bl	rt_tick_get
 2290              	.LVL251:
 2291 00e0 8046     		mov	r8, r0
 2292              	.LVL252:
ARM GAS  /tmp/ccDOLSjn.s 			page 82


1689:rt_thread/src/ipc.c **** 
 2293              		.loc 1 1689 55 is_stmt 1 view .LVU802
1692:rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
 2294              		.loc 1 1692 13 view .LVU803
 2295 00e2 04F14405 		add	r5, r4, #68
 2296 00e6 01AA     		add	r2, sp, #4
 2297 00e8 0021     		movs	r1, #0
 2298 00ea 2846     		mov	r0, r5
 2299              	.LVL253:
1692:rt_thread/src/ipc.c ****                              RT_TIMER_CTRL_SET_TIME,
 2300              		.loc 1 1692 13 is_stmt 0 view .LVU804
 2301 00ec FFF7FEFF 		bl	rt_timer_control
 2302              	.LVL254:
1695:rt_thread/src/ipc.c ****         }
 2303              		.loc 1 1695 13 is_stmt 1 view .LVU805
 2304 00f0 2846     		mov	r0, r5
 2305 00f2 FFF7FEFF 		bl	rt_timer_start
 2306              	.LVL255:
 2307 00f6 B0E7     		b	.L114
 2308              	.LVL256:
 2309              	.L127:
1717:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 2310              		.loc 1 1717 13 view .LVU806
1717:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 2311              		.loc 1 1717 26 is_stmt 0 view .LVU807
 2312 00f8 FFF7FEFF 		bl	rt_tick_get
 2313              	.LVL257:
1717:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 2314              		.loc 1 1717 24 view .LVU808
 2315 00fc A0EB0802 		sub	r2, r0, r8
 2316              	.LVL258:
1718:rt_thread/src/ipc.c ****             if (timeout < 0)
 2317              		.loc 1 1718 13 is_stmt 1 view .LVU809
1718:rt_thread/src/ipc.c ****             if (timeout < 0)
 2318              		.loc 1 1718 21 is_stmt 0 view .LVU810
 2319 0100 A8EB0000 		sub	r0, r8, r0
 2320 0104 019B     		ldr	r3, [sp, #4]
 2321 0106 1844     		add	r0, r0, r3
 2322 0108 0190     		str	r0, [sp, #4]
1719:rt_thread/src/ipc.c ****                 timeout = 0;
 2323              		.loc 1 1719 13 is_stmt 1 view .LVU811
1719:rt_thread/src/ipc.c ****                 timeout = 0;
 2324              		.loc 1 1719 16 is_stmt 0 view .LVU812
 2325 010a 0028     		cmp	r0, #0
 2326 010c 01DB     		blt	.L131
1717:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 2327              		.loc 1 1717 24 view .LVU813
 2328 010e 9046     		mov	r8, r2
 2329 0110 B1E7     		b	.L116
 2330              	.L131:
1720:rt_thread/src/ipc.c ****         }
 2331              		.loc 1 1720 17 is_stmt 1 view .LVU814
1720:rt_thread/src/ipc.c ****         }
 2332              		.loc 1 1720 25 is_stmt 0 view .LVU815
 2333 0112 0023     		movs	r3, #0
 2334 0114 0193     		str	r3, [sp, #4]
1717:rt_thread/src/ipc.c ****             timeout -= tick_delta;
ARM GAS  /tmp/ccDOLSjn.s 			page 83


 2335              		.loc 1 1717 24 view .LVU816
 2336 0116 9046     		mov	r8, r2
 2337 0118 ADE7     		b	.L116
 2338              	.LVL259:
 2339              	.L121:
1717:rt_thread/src/ipc.c ****             timeout -= tick_delta;
 2340              		.loc 1 1717 24 view .LVU817
 2341 011a 4FF00008 		mov	r8, #0
 2342 011e AAE7     		b	.L116
 2343              	.LVL260:
 2344              	.L128:
1725:rt_thread/src/ipc.c **** 
 2345              		.loc 1 1725 5 is_stmt 1 view .LVU818
1725:rt_thread/src/ipc.c **** 
 2346              		.loc 1 1725 16 is_stmt 0 view .LVU819
 2347 0120 F369     		ldr	r3, [r6, #28]
1725:rt_thread/src/ipc.c **** 
 2348              		.loc 1 1725 29 view .LVU820
 2349 0122 F28C     		ldrh	r2, [r6, #38]
1725:rt_thread/src/ipc.c **** 
 2350              		.loc 1 1725 26 view .LVU821
 2351 0124 53F82230 		ldr	r3, [r3, r2, lsl #2]
1725:rt_thread/src/ipc.c **** 
 2352              		.loc 1 1725 12 view .LVU822
 2353 0128 C9F80030 		str	r3, [r9]
1728:rt_thread/src/ipc.c ****     if (mb->out_offset >= mb->size)
 2354              		.loc 1 1728 5 is_stmt 1 view .LVU823
1728:rt_thread/src/ipc.c ****     if (mb->out_offset >= mb->size)
 2355              		.loc 1 1728 10 is_stmt 0 view .LVU824
 2356 012c F38C     		ldrh	r3, [r6, #38]
1728:rt_thread/src/ipc.c ****     if (mb->out_offset >= mb->size)
 2357              		.loc 1 1728 5 view .LVU825
 2358 012e 0133     		adds	r3, r3, #1
 2359 0130 9BB2     		uxth	r3, r3
 2360 0132 F384     		strh	r3, [r6, #38]	@ movhi
1729:rt_thread/src/ipc.c ****         mb->out_offset = 0;
 2361              		.loc 1 1729 5 is_stmt 1 view .LVU826
1729:rt_thread/src/ipc.c ****         mb->out_offset = 0;
 2362              		.loc 1 1729 29 is_stmt 0 view .LVU827
 2363 0134 328C     		ldrh	r2, [r6, #32]
1729:rt_thread/src/ipc.c ****         mb->out_offset = 0;
 2364              		.loc 1 1729 8 view .LVU828
 2365 0136 9342     		cmp	r3, r2
 2366 0138 01D3     		bcc	.L118
1730:rt_thread/src/ipc.c **** 
 2367              		.loc 1 1730 9 is_stmt 1 view .LVU829
1730:rt_thread/src/ipc.c **** 
 2368              		.loc 1 1730 24 is_stmt 0 view .LVU830
 2369 013a 0023     		movs	r3, #0
 2370 013c F384     		strh	r3, [r6, #38]	@ movhi
 2371              	.L118:
1733:rt_thread/src/ipc.c ****     {
 2372              		.loc 1 1733 5 is_stmt 1 view .LVU831
1733:rt_thread/src/ipc.c ****     {
 2373              		.loc 1 1733 10 is_stmt 0 view .LVU832
 2374 013e 738C     		ldrh	r3, [r6, #34]
1733:rt_thread/src/ipc.c ****     {
ARM GAS  /tmp/ccDOLSjn.s 			page 84


 2375              		.loc 1 1733 7 view .LVU833
 2376 0140 0BB1     		cbz	r3, .L119
1735:rt_thread/src/ipc.c ****     }
 2377              		.loc 1 1735 9 is_stmt 1 view .LVU834
1735:rt_thread/src/ipc.c ****     }
 2378              		.loc 1 1735 19 is_stmt 0 view .LVU835
 2379 0142 013B     		subs	r3, r3, #1
 2380 0144 7384     		strh	r3, [r6, #34]	@ movhi
 2381              	.L119:
1739:rt_thread/src/ipc.c ****     {
 2382              		.loc 1 1739 5 is_stmt 1 view .LVU836
1739:rt_thread/src/ipc.c ****     {
 2383              		.loc 1 1739 26 is_stmt 0 view .LVU837
 2384 0146 06F12803 		add	r3, r6, #40
 2385              	.LVL261:
 2386              	.LBB199:
 2387              	.LBI199:
  98:rt_thread/include/rtservice.h **** {
 2388              		.loc 2 98 15 is_stmt 1 view .LVU838
 2389              	.LBB200:
 2390              		.loc 2 100 5 view .LVU839
 2391              		.loc 2 100 13 is_stmt 0 view .LVU840
 2392 014a B06A     		ldr	r0, [r6, #40]
 2393              	.LVL262:
 2394              		.loc 2 100 13 view .LVU841
 2395              	.LBE200:
 2396              	.LBE199:
1739:rt_thread/src/ipc.c ****     {
 2397              		.loc 1 1739 8 view .LVU842
 2398 014c 8342     		cmp	r3, r0
 2399 014e 09D0     		beq	.L120
1741:rt_thread/src/ipc.c **** 
 2400              		.loc 1 1741 9 is_stmt 1 view .LVU843
 2401              	.LVL263:
 2402              	.LBB201:
 2403              	.LBI201:
 140:rt_thread/src/ipc.c **** {
 2404              		.loc 1 140 20 view .LVU844
 2405              	.LBB202:
 142:rt_thread/src/ipc.c **** 
 2406              		.loc 1 142 5 view .LVU845
 145:rt_thread/src/ipc.c **** 
 2407              		.loc 1 145 5 view .LVU846
 147:rt_thread/src/ipc.c **** 
 2408              		.loc 1 147 69 view .LVU847
 150:rt_thread/src/ipc.c **** 
 2409              		.loc 1 150 5 view .LVU848
 2410 0150 1438     		subs	r0, r0, #20
 2411              	.LVL264:
 150:rt_thread/src/ipc.c **** 
 2412              		.loc 1 150 5 is_stmt 0 view .LVU849
 2413 0152 FFF7FEFF 		bl	rt_thread_resume
 2414              	.LVL265:
 152:rt_thread/src/ipc.c **** }
 2415              		.loc 1 152 5 is_stmt 1 view .LVU850
 152:rt_thread/src/ipc.c **** }
 2416              		.loc 1 152 5 is_stmt 0 view .LVU851
ARM GAS  /tmp/ccDOLSjn.s 			page 85


 2417              	.LBE202:
 2418              	.LBE201:
1744:rt_thread/src/ipc.c **** 
 2419              		.loc 1 1744 9 is_stmt 1 view .LVU852
 2420 0156 3846     		mov	r0, r7
 2421 0158 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2422              	.LVL266:
1746:rt_thread/src/ipc.c **** 
 2423              		.loc 1 1746 73 view .LVU853
1748:rt_thread/src/ipc.c **** 
 2424              		.loc 1 1748 9 view .LVU854
 2425 015c FFF7FEFF 		bl	rt_schedule
 2426              	.LVL267:
1750:rt_thread/src/ipc.c ****     }
 2427              		.loc 1 1750 9 view .LVU855
1750:rt_thread/src/ipc.c ****     }
 2428              		.loc 1 1750 16 is_stmt 0 view .LVU856
 2429 0160 0020     		movs	r0, #0
 2430 0162 6CE7     		b	.L103
 2431              	.L120:
1754:rt_thread/src/ipc.c **** 
 2432              		.loc 1 1754 5 is_stmt 1 view .LVU857
 2433 0164 3846     		mov	r0, r7
 2434 0166 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2435              	.LVL268:
1756:rt_thread/src/ipc.c **** 
 2436              		.loc 1 1756 69 view .LVU858
1758:rt_thread/src/ipc.c **** }
 2437              		.loc 1 1758 5 view .LVU859
1758:rt_thread/src/ipc.c **** }
 2438              		.loc 1 1758 12 is_stmt 0 view .LVU860
 2439 016a 0020     		movs	r0, #0
 2440 016c 67E7     		b	.L103
 2441              		.cfi_endproc
 2442              	.LFE33:
 2444              		.section	.text.rt_mb_control,"ax",%progbits
 2445              		.align	1
 2446              		.global	rt_mb_control
 2447              		.syntax unified
 2448              		.thumb
 2449              		.thumb_func
 2451              	rt_mb_control:
 2452              	.LVL269:
 2453              	.LFB34:
1760:rt_thread/src/ipc.c **** 
1761:rt_thread/src/ipc.c **** /**
1762:rt_thread/src/ipc.c ****  * This function can get or set some extra attributions of a mailbox object.
1763:rt_thread/src/ipc.c ****  *
1764:rt_thread/src/ipc.c ****  * @param mb the mailbox object
1765:rt_thread/src/ipc.c ****  * @param cmd the execution command
1766:rt_thread/src/ipc.c ****  * @param arg the execution argument
1767:rt_thread/src/ipc.c ****  *
1768:rt_thread/src/ipc.c ****  * @return the error code
1769:rt_thread/src/ipc.c ****  */
1770:rt_thread/src/ipc.c **** rt_err_t rt_mb_control(rt_mailbox_t mb, int cmd, void *arg)
1771:rt_thread/src/ipc.c **** {
 2454              		.loc 1 1771 1 is_stmt 1 view -0
ARM GAS  /tmp/ccDOLSjn.s 			page 86


 2455              		.cfi_startproc
 2456              		@ args = 0, pretend = 0, frame = 0
 2457              		@ frame_needed = 0, uses_anonymous_args = 0
1772:rt_thread/src/ipc.c ****     rt_ubase_t level;
 2458              		.loc 1 1772 5 view .LVU862
1773:rt_thread/src/ipc.c **** 
1774:rt_thread/src/ipc.c ****     /* parameter check */
1775:rt_thread/src/ipc.c ****     RT_ASSERT(mb != RT_NULL);
 2459              		.loc 1 1775 29 view .LVU863
1776:rt_thread/src/ipc.c ****     RT_ASSERT(rt_object_get_type(&mb->parent.parent) == RT_Object_Class_MailBox);
 2460              		.loc 1 1776 81 view .LVU864
1777:rt_thread/src/ipc.c **** 
1778:rt_thread/src/ipc.c ****     if (cmd == RT_IPC_CMD_RESET)
 2461              		.loc 1 1778 5 view .LVU865
 2462              		.loc 1 1778 8 is_stmt 0 view .LVU866
 2463 0000 0129     		cmp	r1, #1
 2464 0002 35D1     		bne	.L138
1771:rt_thread/src/ipc.c ****     rt_ubase_t level;
 2465              		.loc 1 1771 1 view .LVU867
 2466 0004 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2467              	.LCFI25:
 2468              		.cfi_def_cfa_offset 24
 2469              		.cfi_offset 3, -24
 2470              		.cfi_offset 4, -20
 2471              		.cfi_offset 5, -16
 2472              		.cfi_offset 6, -12
 2473              		.cfi_offset 7, -8
 2474              		.cfi_offset 14, -4
 2475 0006 0646     		mov	r6, r0
1779:rt_thread/src/ipc.c ****     {
1780:rt_thread/src/ipc.c ****         /* disable interrupt */
1781:rt_thread/src/ipc.c ****         level = rt_hw_interrupt_disable();
 2476              		.loc 1 1781 9 is_stmt 1 view .LVU868
 2477              		.loc 1 1781 17 is_stmt 0 view .LVU869
 2478 0008 FFF7FEFF 		bl	rt_hw_interrupt_disable
 2479              	.LVL270:
 2480              		.loc 1 1781 17 view .LVU870
 2481 000c 0746     		mov	r7, r0
 2482              	.LVL271:
1782:rt_thread/src/ipc.c **** 
1783:rt_thread/src/ipc.c ****         /* resume all waiting thread */
1784:rt_thread/src/ipc.c ****         rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
 2483              		.loc 1 1784 9 is_stmt 1 view .LVU871
 2484 000e 06F11405 		add	r5, r6, #20
 2485              	.LVL272:
 2486              	.LBB211:
 2487              	.LBI211:
 163:rt_thread/src/ipc.c **** {
 2488              		.loc 1 163 20 view .LVU872
 2489              	.LBB212:
 165:rt_thread/src/ipc.c ****     register rt_ubase_t temp;
 2490              		.loc 1 165 5 view .LVU873
 166:rt_thread/src/ipc.c **** 
 2491              		.loc 1 166 5 view .LVU874
 169:rt_thread/src/ipc.c ****     {
 2492              		.loc 1 169 5 view .LVU875
 169:rt_thread/src/ipc.c ****     {
ARM GAS  /tmp/ccDOLSjn.s 			page 87


 2493              		.loc 1 169 11 is_stmt 0 view .LVU876
 2494 0012 0CE0     		b	.L134
 2495              	.LVL273:
 2496              	.L135:
 172:rt_thread/src/ipc.c **** 
 2497              		.loc 1 172 9 is_stmt 1 view .LVU877
 172:rt_thread/src/ipc.c **** 
 2498              		.loc 1 172 16 is_stmt 0 view .LVU878
 2499 0014 FFF7FEFF 		bl	rt_hw_interrupt_disable
 2500              	.LVL274:
 2501 0018 0446     		mov	r4, r0
 2502              	.LVL275:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2503              		.loc 1 175 9 is_stmt 1 view .LVU879
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2504              		.loc 1 175 18 is_stmt 0 view .LVU880
 2505 001a 2868     		ldr	r0, [r5]
 2506              	.LVL276:
 177:rt_thread/src/ipc.c **** 
 2507              		.loc 1 177 9 is_stmt 1 view .LVU881
 177:rt_thread/src/ipc.c **** 
 2508              		.loc 1 177 23 is_stmt 0 view .LVU882
 2509 001c 4FF0FF33 		mov	r3, #-1
 2510 0020 C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 2511              		.loc 1 184 9 is_stmt 1 view .LVU883
 2512 0022 1438     		subs	r0, r0, #20
 2513              	.LVL277:
 184:rt_thread/src/ipc.c **** 
 2514              		.loc 1 184 9 is_stmt 0 view .LVU884
 2515 0024 FFF7FEFF 		bl	rt_thread_resume
 2516              	.LVL278:
 187:rt_thread/src/ipc.c ****     }
 2517              		.loc 1 187 9 is_stmt 1 view .LVU885
 2518 0028 2046     		mov	r0, r4
 2519 002a FFF7FEFF 		bl	rt_hw_interrupt_enable
 2520              	.LVL279:
 2521              	.L134:
 169:rt_thread/src/ipc.c ****     {
 2522              		.loc 1 169 11 view .LVU886
 2523              	.LBB213:
 2524              	.LBI213:
  98:rt_thread/include/rtservice.h **** {
 2525              		.loc 2 98 15 view .LVU887
 2526              	.LBB214:
 2527              		.loc 2 100 5 view .LVU888
 2528              		.loc 2 100 13 is_stmt 0 view .LVU889
 2529 002e 2B68     		ldr	r3, [r5]
 2530              	.LVL280:
 2531              		.loc 2 100 13 view .LVU890
 2532              	.LBE214:
 2533              	.LBE213:
 169:rt_thread/src/ipc.c ****     {
 2534              		.loc 1 169 11 view .LVU891
 2535 0030 9D42     		cmp	r5, r3
 2536 0032 EFD1     		bne	.L135
 190:rt_thread/src/ipc.c **** }
ARM GAS  /tmp/ccDOLSjn.s 			page 88


 2537              		.loc 1 190 5 is_stmt 1 view .LVU892
 2538              	.LVL281:
 190:rt_thread/src/ipc.c **** }
 2539              		.loc 1 190 5 is_stmt 0 view .LVU893
 2540              	.LBE212:
 2541              	.LBE211:
1785:rt_thread/src/ipc.c ****         /* also resume all mailbox private suspended thread */
1786:rt_thread/src/ipc.c ****         rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
 2542              		.loc 1 1786 9 is_stmt 1 view .LVU894
 2543 0034 06F12805 		add	r5, r6, #40
 2544              	.LVL282:
 2545              	.LBB215:
 2546              	.LBI215:
 163:rt_thread/src/ipc.c **** {
 2547              		.loc 1 163 20 view .LVU895
 2548 0038 0CE0     		b	.L136
 2549              	.L137:
 2550              	.LBB216:
 172:rt_thread/src/ipc.c **** 
 2551              		.loc 1 172 9 view .LVU896
 172:rt_thread/src/ipc.c **** 
 2552              		.loc 1 172 16 is_stmt 0 view .LVU897
 2553 003a FFF7FEFF 		bl	rt_hw_interrupt_disable
 2554              	.LVL283:
 2555 003e 0446     		mov	r4, r0
 2556              	.LVL284:
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2557              		.loc 1 175 9 is_stmt 1 view .LVU898
 175:rt_thread/src/ipc.c ****         /* set error code to RT_ERROR */
 2558              		.loc 1 175 18 is_stmt 0 view .LVU899
 2559 0040 2868     		ldr	r0, [r5]
 2560              	.LVL285:
 177:rt_thread/src/ipc.c **** 
 2561              		.loc 1 177 9 is_stmt 1 view .LVU900
 177:rt_thread/src/ipc.c **** 
 2562              		.loc 1 177 23 is_stmt 0 view .LVU901
 2563 0042 4FF0FF33 		mov	r3, #-1
 2564 0046 C361     		str	r3, [r0, #28]
 184:rt_thread/src/ipc.c **** 
 2565              		.loc 1 184 9 is_stmt 1 view .LVU902
 2566 0048 1438     		subs	r0, r0, #20
 2567              	.LVL286:
 184:rt_thread/src/ipc.c **** 
 2568              		.loc 1 184 9 is_stmt 0 view .LVU903
 2569 004a FFF7FEFF 		bl	rt_thread_resume
 2570              	.LVL287:
 187:rt_thread/src/ipc.c ****     }
 2571              		.loc 1 187 9 is_stmt 1 view .LVU904
 2572 004e 2046     		mov	r0, r4
 2573 0050 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2574              	.LVL288:
 2575              	.L136:
 169:rt_thread/src/ipc.c ****     {
 2576              		.loc 1 169 11 view .LVU905
 2577              	.LBB217:
 2578              	.LBI217:
  98:rt_thread/include/rtservice.h **** {
ARM GAS  /tmp/ccDOLSjn.s 			page 89


 2579              		.loc 2 98 15 view .LVU906
 2580              	.LBB218:
 2581              		.loc 2 100 5 view .LVU907
 2582              		.loc 2 100 13 is_stmt 0 view .LVU908
 2583 0054 2B68     		ldr	r3, [r5]
 2584              	.LVL289:
 2585              		.loc 2 100 13 view .LVU909
 2586              	.LBE218:
 2587              	.LBE217:
 169:rt_thread/src/ipc.c ****     {
 2588              		.loc 1 169 11 view .LVU910
 2589 0056 9D42     		cmp	r5, r3
 2590 0058 EFD1     		bne	.L137
 190:rt_thread/src/ipc.c **** }
 2591              		.loc 1 190 5 is_stmt 1 view .LVU911
 2592              	.LVL290:
 190:rt_thread/src/ipc.c **** }
 2593              		.loc 1 190 5 is_stmt 0 view .LVU912
 2594              	.LBE216:
 2595              	.LBE215:
1787:rt_thread/src/ipc.c **** 
1788:rt_thread/src/ipc.c ****         /* re-init mailbox */
1789:rt_thread/src/ipc.c ****         mb->entry      = 0;
 2596              		.loc 1 1789 9 is_stmt 1 view .LVU913
 2597              		.loc 1 1789 24 is_stmt 0 view .LVU914
 2598 005a 0024     		movs	r4, #0
 2599 005c 7484     		strh	r4, [r6, #34]	@ movhi
1790:rt_thread/src/ipc.c ****         mb->in_offset  = 0;
 2600              		.loc 1 1790 9 is_stmt 1 view .LVU915
 2601              		.loc 1 1790 24 is_stmt 0 view .LVU916
 2602 005e B484     		strh	r4, [r6, #36]	@ movhi
1791:rt_thread/src/ipc.c ****         mb->out_offset = 0;
 2603              		.loc 1 1791 9 is_stmt 1 view .LVU917
 2604              		.loc 1 1791 24 is_stmt 0 view .LVU918
 2605 0060 F484     		strh	r4, [r6, #38]	@ movhi
1792:rt_thread/src/ipc.c **** 
1793:rt_thread/src/ipc.c ****         /* enable interrupt */
1794:rt_thread/src/ipc.c ****         rt_hw_interrupt_enable(level);
 2606              		.loc 1 1794 9 is_stmt 1 view .LVU919
 2607 0062 3846     		mov	r0, r7
 2608 0064 FFF7FEFF 		bl	rt_hw_interrupt_enable
 2609              	.LVL291:
1795:rt_thread/src/ipc.c **** 
1796:rt_thread/src/ipc.c ****         rt_schedule();
 2610              		.loc 1 1796 9 view .LVU920
 2611 0068 FFF7FEFF 		bl	rt_schedule
 2612              	.LVL292:
1797:rt_thread/src/ipc.c **** 
1798:rt_thread/src/ipc.c ****         return RT_EOK;
 2613              		.loc 1 1798 9 view .LVU921
 2614              		.loc 1 1798 16 is_stmt 0 view .LVU922
 2615 006c 2046     		mov	r0, r4
1799:rt_thread/src/ipc.c ****     }
1800:rt_thread/src/ipc.c **** 
1801:rt_thread/src/ipc.c ****     return -RT_ERROR;
1802:rt_thread/src/ipc.c **** }
 2616              		.loc 1 1802 1 view .LVU923
ARM GAS  /tmp/ccDOLSjn.s 			page 90


 2617 006e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2618              	.LVL293:
 2619              	.L138:
 2620              	.LCFI26:
 2621              		.cfi_def_cfa_offset 0
 2622              		.cfi_restore 3
 2623              		.cfi_restore 4
 2624              		.cfi_restore 5
 2625              		.cfi_restore 6
 2626              		.cfi_restore 7
 2627              		.cfi_restore 14
1801:rt_thread/src/ipc.c **** }
 2628              		.loc 1 1801 12 view .LVU924
 2629 0070 4FF0FF30 		mov	r0, #-1
 2630              	.LVL294:
 2631              		.loc 1 1802 1 view .LVU925
 2632 0074 7047     		bx	lr
 2633              		.cfi_endproc
 2634              	.LFE34:
 2636              		.text
 2637              	.Letext0:
 2638              		.file 3 "rt_thread/include/rtdef.h"
 2639              		.file 4 "rt_thread/include/rthw.h"
 2640              		.file 5 "rt_thread/include/rtthread.h"
ARM GAS  /tmp/ccDOLSjn.s 			page 91


DEFINED SYMBOLS
                            *ABS*:0000000000000000 ipc.c
     /tmp/ccDOLSjn.s:18     .text.rt_sem_init:0000000000000000 $t
     /tmp/ccDOLSjn.s:24     .text.rt_sem_init:0000000000000000 rt_sem_init
     /tmp/ccDOLSjn.s:95     .text.rt_sem_detach:0000000000000000 $t
     /tmp/ccDOLSjn.s:101    .text.rt_sem_detach:0000000000000000 rt_sem_detach
     /tmp/ccDOLSjn.s:192    .text.rt_sem_create:0000000000000000 $t
     /tmp/ccDOLSjn.s:198    .text.rt_sem_create:0000000000000000 rt_sem_create
     /tmp/ccDOLSjn.s:276    .text.rt_sem_delete:0000000000000000 $t
     /tmp/ccDOLSjn.s:282    .text.rt_sem_delete:0000000000000000 rt_sem_delete
     /tmp/ccDOLSjn.s:374    .text.rt_sem_take:0000000000000000 $t
     /tmp/ccDOLSjn.s:380    .text.rt_sem_take:0000000000000000 rt_sem_take
     /tmp/ccDOLSjn.s:658    .text.rt_sem_trytake:0000000000000000 $t
     /tmp/ccDOLSjn.s:664    .text.rt_sem_trytake:0000000000000000 rt_sem_trytake
     /tmp/ccDOLSjn.s:688    .text.rt_sem_release:0000000000000000 $t
     /tmp/ccDOLSjn.s:694    .text.rt_sem_release:0000000000000000 rt_sem_release
     /tmp/ccDOLSjn.s:824    .text.rt_sem_control:0000000000000000 $t
     /tmp/ccDOLSjn.s:830    .text.rt_sem_control:0000000000000000 rt_sem_control
     /tmp/ccDOLSjn.s:961    .text.rt_mb_init:0000000000000000 $t
     /tmp/ccDOLSjn.s:967    .text.rt_mb_init:0000000000000000 rt_mb_init
     /tmp/ccDOLSjn.s:1065   .text.rt_mb_detach:0000000000000000 $t
     /tmp/ccDOLSjn.s:1071   .text.rt_mb_detach:0000000000000000 rt_mb_detach
     /tmp/ccDOLSjn.s:1216   .text.rt_mb_create:0000000000000000 $t
     /tmp/ccDOLSjn.s:1222   .text.rt_mb_create:0000000000000000 rt_mb_create
     /tmp/ccDOLSjn.s:1349   .text.rt_mb_delete:0000000000000000 $t
     /tmp/ccDOLSjn.s:1355   .text.rt_mb_delete:0000000000000000 rt_mb_delete
     /tmp/ccDOLSjn.s:1505   .text.rt_mb_send_wait:0000000000000000 $t
     /tmp/ccDOLSjn.s:1511   .text.rt_mb_send_wait:0000000000000000 rt_mb_send_wait
     /tmp/ccDOLSjn.s:1963   .text.rt_mb_send:0000000000000000 $t
     /tmp/ccDOLSjn.s:1969   .text.rt_mb_send:0000000000000000 rt_mb_send
     /tmp/ccDOLSjn.s:1993   .text.rt_mb_recv:0000000000000000 $t
     /tmp/ccDOLSjn.s:1999   .text.rt_mb_recv:0000000000000000 rt_mb_recv
     /tmp/ccDOLSjn.s:2445   .text.rt_mb_control:0000000000000000 $t
     /tmp/ccDOLSjn.s:2451   .text.rt_mb_control:0000000000000000 rt_mb_control

UNDEFINED SYMBOLS
rt_object_init
rt_hw_interrupt_disable
rt_thread_resume
rt_hw_interrupt_enable
rt_object_detach
rt_object_allocate
rt_object_delete
rt_thread_self
rt_thread_suspend
rt_schedule
rt_timer_control
rt_timer_start
rt_malloc
rt_free
rt_tick_get
